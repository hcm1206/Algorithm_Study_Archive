# solved\.ac 랜덤 마라톤 42주차

<img src="./img/week42unsolved.PNG">

---

## A
### #24079 : 移動 (Moving)
https://www.acmicpc.net/problem/24079

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/2.svg' width='30'>

#### 사용 알고리즘

**#수학**  
**#사칙연산**  

#### 풀이

A 지점에서 B 지점까지의 소요시간과 B 지점에서 C 지점까지의 소요시간이 주어졌을 때 A 지점에서 B 지점을 거쳐 C 지점을 가는데 걸리는 소요시간이 Z시간 30분보다 작은지 판정하는 문제.

1. A 지점에서 B 지점까지의 소요시간 `x`, B 지점에서 C 지점까지의 소요시간 `y`, 비교할 시간 `z`를 입력받는다.
2. `x` + `y`의 값이 `z`보다 작다면 `0`을 출력하고, `x` + `y`의 값이 `z`보다 크거나 같다면 `1`을 출력한다.

#### 코멘트

단순한 덧셈 연산 후 조건식을 비교하는 사칙연산 문제이다. 브론즈4보다는 브론즈5에 더 가까운 수준의 난이도가 아닌가 싶다.  
  
뜬금없이 일본어 문제가 출몰해서 확인해봤더니 추천 받는 문제가 '일정 수듄' 이상이라며 더 이상 언어 편식을 못하게 막아놨다.  

<img src="./img/language.PNG">
  
뭐야 내 영어 및 한국어 문제 돌려줘요  

---

## B
### #27482 : Block Adventure
https://www.acmicpc.net/problem/27482

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/9.svg' width='30'>

#### 사용 알고리즘

**#그리디 알고리즘**  

#### 풀이

일렬로 각기 다른 높이를 가진 블록 탑을 차례대로 오르내리며 여분의 블록을 저장하고 꺼내는 과정을 통해 마지막 블록 탑에 도달할 수 있는지 파악하는 문제.

1. **테스트 케이스 개수 `t`를 입력받아 아래 과정을 `t`번 반복**한다.
    - 1-1. **블록 탑 개수 `n`, 초기 여분 블록 `m`, 넘을 수 있는 블록 높이 `k` 변수를 선언하여 입력받는다.**
    - 1-2. **블록을 넘을 수 있는지 여부를 판정할 bool 변수 `valid`를 선언하고 true로 초기화**한다.
    - 1-3. **`prev` 변수를 선언한 후 첫 번째 블록 탑의 높이를 입력받아 저장**한다.
    - 1-4. **두 번째 탑부터 `n`번째 탑까지 아래 과정을 반복**한다.
        - 1-4-1. **이번 탑의 높이 `h`를 입력받은 후 조건에 따라 아래 과정을 수행**한다.
            - case 1. 만약 **이번 탑의 높이가 이전 탑에서 넘을 수 있는 높이 이상(`prev` + `k` ≤ `h`)이라면, 조건에 따라 아래 과정을 수행**한다.
                - case 1-1. 만약 **여분의 블록을 모두 사용해도 이번 탑 높이에 도달할 수 없다면(`prev` + `k` + `m` < `h`)**, 더 이상 탑을 통과할 수 없으므로 **`valid` 변수를 false로 바꾼다.**
                - case 1-2. 만약 **여분 블록을 사용해서 이번 탑 높이에 도달할 수 있다면, 여분 블록 `m`에서 필요한 만큼 블록을 제거**한다.
            - case 2. 만약 **이번 탑의 높이가 이전 탑에서 넘을 수 있는 높이 미만이라면, 이번 블록을 넘기 위한 최소 높이(max(0, `h` - `k`))를 계산한 뒤**, 이전 탑 높이와 최소 높이의 차를 통해 **이전 탑에서 빼낼 수 있는 최대 블록 개수를 구해서 여분 블록 `m`에 추가**한다.
        - 1-4-2. **이전 탑 높이 `prev` 값을 이번 탑 높이 `h` 값으로 바꾼다.**
    - 1-5. 모든 탑을 순회한 후 **`valid` 변수가 true라면** 마지막 탑까지 도달할 수 있다는 뜻이므로 **"YES"를 출력**한다. 만약 **false라면 "NO"를 출력**한다.
  
블록 탑을 넘어가기 위해 필요한 최소 높이를 계산한 뒤, 여분으로 저장할 수 있는 블록은 남기지 말고 최대한 저장하는 그리디 알고리즘으로 해결 가능한 문제이다.  

#### 코멘트

발상 자체는 어렵지 않은 그리디 문제이다.  
블록을 남기고 간다고 해서 이후 과정에 끼치는 영향이 전혀 없기 때문에 가져갈 수 있는 블록은 최대한 가져가는 것이 핵심이다.  
  
오히려 발상보다는 구현이 더 까다로웠는데, 넘을 수 있는 최소 높이를 계산하는 과정에서 음수가 되어버리거나, 이전 타워의 높이가 0인데 나올리가 없는 여분의 블록을 저장하는 등 생각치 못한 예외 조건들이 튀어나와서 오답이 2번이나 나왔다.  
알고리즘 풀이를 쉽게 떠올렸다고 만만하게 구현했다가 큰 코 다친 문제이다.  
  
여분 블록을 저장하면서 오버플로우가 나지 않을까 쫄았는데 각 블록 탑의 최대 높이가 $10^{6}$이고, 탑의 최대 개수가 100($10^{2}$)이기 때문에 저장할 수 있는 최대 여분 블록은 $10^{8}$로 int형 변수 범위로 커버할 수 있었다.

---

## C
### #26580 : Rain
https://www.acmicpc.net/problem/26580

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/11.svg' width='30'>

#### 사용 알고리즘

**#구현**  
**#시뮬레이션**  

#### 풀이

높이가 각각 다른 여러 개의 칸으로 이루어진 1차원 배열 형태의 빗물받이통에 모을 수 있는 빗물의 양을 계산하는 문제.

1. 계산할 **빗물받이 통 개수 `n`을 입력받는다.** (이후 공백 포함 문자열을 받기 위한 getline() 함수를 사용하기 위해 cin.ignore() 함수를 실행한다.)
2. 빗물받이 통의 개수 **`n`만큼 아래 과정을 반복하며 받을 수 있는 빗물의 양을 계산**한다.
    - 2-1. **빗물받이 통 정보를 문자열로 받은 후, 각각의 숫자를 추출하여 빗물받이 통의 각 칸 높이를 배열 `v`에 저장**한다.
    - 2-2. **빗물의 양을 누적할 `total` 변수를 선언하고 0으로 초기화**한다.
    - 2-3. 빗물받이 배열 **`v`의 두 번째 배열부터 마지막 두 번째 까지의 원소를 반복(`v[i]`)하며 아래 과정을 통해 각 칸에서 모을 수 있는 빗물의 최대 양을 계산**한다. (첫 번째 원소와 마지막 원소 위치에서는 옆이 뚫려있기 때문에 빗물을 모을 수 없다.)
        - 2-3-1. **현재 칸 위치 인덱스 `i`를 기준으로 좌측과 우측에 위치한 원소 중 가장 큰 높이를 저장할 변수 `lmax`, `rmax`를 선언하고 -1000000001로 초기화**한다. (각 원소는 최소 -1000000000까지 저장될 수 있다.)
        - 2-3-2. **현재 칸 위치 인덱스 `i`를 기준으로 좌측의 모든 원소를 순회하며 가장 높은 높이를 `lmax`에 저장**한다.
        - 2-3-3. **현재 칸 위치 인덱스 `i`를 기준으로 우측의 모든 원소를 순회하며 가장 높은 높이를 `rmax`에 저장**한다.
        - 2-3-4. 만약 **`lmax`와 `rmax`가 `v[i]`보다 크다면,** `i` 위치에는 `lmax`와 `rmax` 높이에 의해 물이 저장될 수 있다는 의미이므로, **모을 수 있는 물의 양인 min(`lmax`, `rmax`) - `v[i]`를 `total`에 누적**한다. (만약 `lmax` 또는 `rmax`가 `v[i]`보다 크지 않다면 `i` 위치에서는 물을 가둘 수 있는 높이가 충족되지 않아 `i` 위치에서 물이 모이지 못하고 빗물받이 통 밖으로 흘러넘칠 것이다.)
    - 2-5. **누적된 `total` 값을 출력**한다.

모을 수 있는 빗물의 양이 최대 $28 × 10^{9}$로 int 범위를 초과하기 때문에, **long long 등의 범위가 큰 타입을 사용해야 오버플로우를 방지할 수 있다.**  

#### 코멘트

오랜만에 등장한 순수 구현 문제이다. 그렇다고 머리를 쥐어짜야 할 수준의 빡구현 문제까지는 아니고 나름 어렵다면 어려울 수 있는데, 또 쉽다고 생각한다면 쉬운 해괴한 난이도의 문제이다.  

문제 자체는 나쁘지 않은데, 풀이 외적인 요소가 매우 불친절하여 썩 마음에 들진 않았던 문제이다.  
빗물받이 통 배열 크기를 입력받지 않고 한 줄의 문자열로 입력받는 형식이라 C++로 풀 때 별도의 파싱 과정이 필요했으며  
무엇보다 배열 크기 `n`이랑 배열 원소 크기의 범위가 제공되지 않아서 최적화가 얼마나 필요한지 문제 지문만으로는 전혀 알 수 없었다.  
다행히 게시판에 어떤 친절한 분이 자체적으로 문제 제한을 조사해놓은 걸 참고해서 풀 수 있었지만 문제를 풀기도 전부터 상당한 불쾌함을 안고 시작했다.  

문제를 처음 읽고 나서는 뭔가 히스토그램 문제처럼 모노톤 스택을 이용해서 최적화를 해야 하나 싶어서 코드를 좀 짜봤는데, 모노톤 스택으로 구현하려니 생각보다 따져야 할 게 많고 로직이 산으로 가는 것 같아서 폐기했다.  
게시판을 보고 제한이 배열 크기 제한이 30이라는 것을 파악한 후에는 그냥 나이브한 $O(n^{2})$ 브루트포스로 풀기로 가닥을 잡고 풀이를 구현하였다.  
이것도 한동안 스택스러운 풀이에 매몰되는 바람에 풀이가 쓸데없이 복잡해지고 무수한 예외 상황이 생기자 풀이를 다시 갈아엎어서 단순화한 게 최종 코드이다.  
  
문제를 조금만 더 단순하게 생각했다면 훨씬 쉽게 풀었을 것 같은데 괜히 쓸데없는 고생을 한 기분이다.  

---

## D
### #7308 : A DP Problem
https://www.acmicpc.net/problem/7308

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## E
### #33553 : Floor Tiling
https://www.acmicpc.net/problem/33553

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## F
### #6002 : Job Hunt
https://www.acmicpc.net/problem/6002

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## G
### #22235 : 가희와 수인 분당선 1
https://www.acmicpc.net/problem/22235

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## H

### #25835 : Lots of Towers of Hanoi
https://www.acmicpc.net/problem/25835

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## 결과 및 후기

| A | B | C | D | E | F | G | H |
|---|---|---|---|---|---|---|---|
| ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |

