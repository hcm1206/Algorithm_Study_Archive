# solved\.ac 랜덤 마라톤 42주차

<img src="./img/week42unsolved.PNG">

---

## A
### #24079 : 移動 (Moving)
https://www.acmicpc.net/problem/24079

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/2.svg' width='30'>

#### 사용 알고리즘

**#수학**  
**#사칙연산**  

#### 풀이

A 지점에서 B 지점까지의 소요시간과 B 지점에서 C 지점까지의 소요시간이 주어졌을 때 A 지점에서 B 지점을 거쳐 C 지점을 가는데 걸리는 소요시간이 Z시간 30분보다 작은지 판정하는 문제.

1. A 지점에서 B 지점까지의 소요시간 `x`, B 지점에서 C 지점까지의 소요시간 `y`, 비교할 시간 `z`를 입력받는다.
2. `x` + `y`의 값이 `z`보다 작다면 `0`을 출력하고, `x` + `y`의 값이 `z`보다 크거나 같다면 `1`을 출력한다.

#### 코멘트

단순한 덧셈 연산 후 조건식을 비교하는 사칙연산 문제이다. 브론즈4보다는 브론즈5에 더 가까운 수준의 난이도가 아닌가 싶다.  
  
뜬금없이 일본어 문제가 출몰해서 확인해봤더니 추천 받는 문제가 '일정 수듄' 이상이라며 더 이상 언어 편식을 못하게 막아놨다.  

<img src="./img/language.PNG">
  
뭐야 내 영어 및 한국어 문제 돌려줘요  

---

## B
### #27482 : Block Adventure
https://www.acmicpc.net/problem/27482

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/9.svg' width='30'>

#### 사용 알고리즘

**#그리디 알고리즘**  

#### 풀이

일렬로 각기 다른 높이를 가진 블록 탑을 차례대로 오르내리며 여분의 블록을 저장하고 꺼내는 과정을 통해 마지막 블록 탑에 도달할 수 있는지 파악하는 문제.

1. **테스트 케이스 개수 `t`를 입력받아 아래 과정을 `t`번 반복**한다.
    - 1-1. **블록 탑 개수 `n`, 초기 여분 블록 `m`, 넘을 수 있는 블록 높이 `k` 변수를 선언하여 입력받는다.**
    - 1-2. **블록을 넘을 수 있는지 여부를 판정할 bool 변수 `valid`를 선언하고 true로 초기화**한다.
    - 1-3. **`prev` 변수를 선언한 후 첫 번째 블록 탑의 높이를 입력받아 저장**한다.
    - 1-4. **두 번째 탑부터 `n`번째 탑까지 아래 과정을 반복**한다.
        - 1-4-1. **이번 탑의 높이 `h`를 입력받은 후 조건에 따라 아래 과정을 수행**한다.
            - case 1. 만약 **이번 탑의 높이가 이전 탑에서 넘을 수 있는 높이 이상(`prev` + `k` ≤ `h`)이라면, 조건에 따라 아래 과정을 수행**한다.
                - case 1-1. 만약 **여분의 블록을 모두 사용해도 이번 탑 높이에 도달할 수 없다면(`prev` + `k` + `m` < `h`)**, 더 이상 탑을 통과할 수 없으므로 **`valid` 변수를 false로 바꾼다.**
                - case 1-2. 만약 **여분 블록을 사용해서 이번 탑 높이에 도달할 수 있다면, 여분 블록 `m`에서 필요한 만큼 블록을 제거**한다.
            - case 2. 만약 **이번 탑의 높이가 이전 탑에서 넘을 수 있는 높이 미만이라면, 이번 블록을 넘기 위한 최소 높이(max(0, `h` - `k`))를 계산한 뒤**, 이전 탑 높이와 최소 높이의 차를 통해 **이전 탑에서 빼낼 수 있는 최대 블록 개수를 구해서 여분 블록 `m`에 추가**한다.
        - 1-4-2. **이전 탑 높이 `prev` 값을 이번 탑 높이 `h` 값으로 바꾼다.**
    - 1-5. 모든 탑을 순회한 후 **`valid` 변수가 true라면** 마지막 탑까지 도달할 수 있다는 뜻이므로 **"YES"를 출력**한다. 만약 **false라면 "NO"를 출력**한다.
  
블록 탑을 넘어가기 위해 필요한 최소 높이를 계산한 뒤, 여분으로 저장할 수 있는 블록은 남기지 말고 최대한 저장하는 그리디 알고리즘으로 해결 가능한 문제이다.  

#### 코멘트

발상 자체는 어렵지 않은 그리디 문제이다.  
블록을 남기고 간다고 해서 이후 과정에 끼치는 영향이 전혀 없기 때문에 가져갈 수 있는 블록은 최대한 가져가는 것이 핵심이다.  
  
오히려 발상보다는 구현이 더 까다로웠는데, 넘을 수 있는 최소 높이를 계산하는 과정에서 음수가 되어버리거나, 이전 타워의 높이가 0인데 나올리가 없는 여분의 블록을 저장하는 등 생각치 못한 예외 조건들이 튀어나와서 오답이 2번이나 나왔다.  
알고리즘 풀이를 쉽게 떠올렸다고 만만하게 구현했다가 큰 코 다친 문제이다.  
  
여분 블록을 저장하면서 오버플로우가 나지 않을까 쫄았는데 각 블록 탑의 최대 높이가 $10^{6}$이고, 탑의 최대 개수가 100($10^{2}$)이기 때문에 저장할 수 있는 최대 여분 블록은 $10^{8}$로 int형 변수 범위로 커버할 수 있었다.

---

## C
### #26580 : Rain
https://www.acmicpc.net/problem/26580

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/11.svg' width='30'>

#### 사용 알고리즘

**#구현**  
**#시뮬레이션**  

#### 풀이

높이가 각각 다른 여러 개의 칸으로 이루어진 1차원 배열 형태의 빗물받이통에 모을 수 있는 빗물의 양을 계산하는 문제.

1. 계산할 **빗물받이 통 개수 `n`을 입력받는다.** (이후 공백 포함 문자열을 받기 위한 getline() 함수를 사용하기 위해 cin.ignore() 함수를 실행한다.)
2. 빗물받이 통의 개수 **`n`만큼 아래 과정을 반복하며 받을 수 있는 빗물의 양을 계산**한다.
    - 2-1. **빗물받이 통 정보를 문자열로 받은 후, 각각의 숫자를 추출하여 빗물받이 통의 각 칸 높이를 배열 `v`에 저장**한다.
    - 2-2. **빗물의 양을 누적할 `total` 변수를 선언하고 0으로 초기화**한다.
    - 2-3. 빗물받이 배열 **`v`의 두 번째 배열부터 마지막 두 번째 까지의 원소를 반복(`v[i]`)하며 아래 과정을 통해 각 칸에서 모을 수 있는 빗물의 최대 양을 계산**한다. (첫 번째 원소와 마지막 원소 위치에서는 옆이 뚫려있기 때문에 빗물을 모을 수 없다.)
        - 2-3-1. **현재 칸 위치 인덱스 `i`를 기준으로 좌측과 우측에 위치한 원소 중 가장 큰 높이를 저장할 변수 `lmax`, `rmax`를 선언하고 -1000000001로 초기화**한다. (각 원소는 최소 -1000000000까지 저장될 수 있다.)
        - 2-3-2. **현재 칸 위치 인덱스 `i`를 기준으로 좌측의 모든 원소를 순회하며 가장 높은 높이를 `lmax`에 저장**한다.
        - 2-3-3. **현재 칸 위치 인덱스 `i`를 기준으로 우측의 모든 원소를 순회하며 가장 높은 높이를 `rmax`에 저장**한다.
        - 2-3-4. 만약 **`lmax`와 `rmax`가 `v[i]`보다 크다면,** `i` 위치에는 `lmax`와 `rmax` 높이에 의해 물이 저장될 수 있다는 의미이므로, **모을 수 있는 물의 양인 min(`lmax`, `rmax`) - `v[i]`를 `total`에 누적**한다. (만약 `lmax` 또는 `rmax`가 `v[i]`보다 크지 않다면 `i` 위치에서는 물을 가둘 수 있는 높이가 충족되지 않아 `i` 위치에서 물이 모이지 못하고 빗물받이 통 밖으로 흘러넘칠 것이다.)
    - 2-5. **누적된 `total` 값을 출력**한다.

모을 수 있는 빗물의 양이 최대 $28 × 10^{9}$로 int 범위를 초과하기 때문에, **long long 등의 범위가 큰 타입을 사용해야 오버플로우를 방지할 수 있다.**  

#### 코멘트

오랜만에 등장한 순수 구현 문제이다. 그렇다고 머리를 쥐어짜야 할 수준의 빡구현 문제까지는 아니고 나름 어렵다면 어려울 수 있는데, 또 쉽다고 생각한다면 쉬운 해괴한 난이도의 문제이다.  

문제 자체는 나쁘지 않은데, 풀이 외적인 요소가 매우 불친절하여 썩 마음에 들진 않았던 문제이다.  
빗물받이 통 배열 크기를 입력받지 않고 한 줄의 문자열로 입력받는 형식이라 C++로 풀 때 별도의 파싱 과정이 필요했으며  
무엇보다 배열 크기 `n`이랑 배열 원소 크기의 범위가 제공되지 않아서 최적화가 얼마나 필요한지 문제 지문만으로는 전혀 알 수 없었다.  
다행히 게시판에 어떤 친절한 분이 자체적으로 문제 제한을 조사해놓은 걸 참고해서 풀 수 있었지만 문제를 풀기도 전부터 상당한 불쾌함을 안고 시작했다.  

문제를 처음 읽고 나서는 뭔가 히스토그램 문제처럼 모노톤 스택을 이용해서 최적화를 해야 하나 싶어서 코드를 좀 짜봤는데, 모노톤 스택으로 구현하려니 생각보다 따져야 할 게 많고 로직이 산으로 가는 것 같아서 폐기했다.  
게시판을 보고 제한이 배열 크기 제한이 30이라는 것을 파악한 후에는 그냥 나이브한 $O(n^{2})$ 브루트포스로 풀기로 가닥을 잡고 풀이를 구현하였다.  
이것도 한동안 스택스러운 풀이에 매몰되는 바람에 풀이가 쓸데없이 복잡해지고 무수한 예외 상황이 생기자 풀이를 다시 갈아엎어서 단순화한 게 최종 코드이다.  
  
문제를 조금만 더 단순하게 생각했다면 훨씬 쉽게 풀었을 것 같은데 괜히 쓸데없는 고생을 한 기분이다.  

---

## D
### #7308 : A DP Problem
https://www.acmicpc.net/problem/7308

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/12.svg' width='30'>

#### 사용 알고리즘

**#수학**  
**#문자열**  
**#파싱**  

#### 풀이

주어진 일차방정식 문자열의 해를 구하는 문제.  

1. **테스트 케이스 개수 `t`를 입력받은 후 `t`번의 테스트 케이스를 아래와 같이 수행**한다.
    - 1-1. **일차방정식 문자열 `str`을 입력**받는다.
    - 1-2. **방정식에서 숫자 부분을 저장할 `num` 문자열을 선언하고 빈 문자열로 초기화**한다.
    - 1-3. **방정식 문자열을 순회하기 위한 인덱스 변수 `idx`를 선언하고 0으로 초기화한 후, 방정식 문자열의 크기 변수 `size`를 선언하여 방정식 문자열 크기를 저장**한다.
    - 1-4. **계수가 아닌 상수인지 여부를 판단하기 위한 bool 변수 `iscon`을 선언하여 true로 초기화하고, 양수인지 여부를 판단하기 위한 bool 변수 `plus`를 선언하고 true로 초기화**한다.
    - 1-5. **좌항과 우항의 계수를 저장할 2 크기의 `coef` 배열을 선언하고, 좌항과 우항의 상수를 저장할 2 크기의 `cons` 배열을 선언**한다. (`coef[0]`과 `cons[0]`은 각각 좌항의 계수와 상수를 나타내고, `coef[1]`과 `cons[1]`은 각각 우항의 계수와 상수를 나타낸다.)
    - 1-6. **현재 식이 좌항인지, 우항인지 나타낼 정수형 변수 `eq`를 선언하고 0으로 초기화**한다. (`eq`가 0이면 좌항, 1이면 우항임을 나타낸다. 이는 인덱스의 역할을 수행하여 `eq`가 0이면 `coef`와 `cons` 배열에서 좌항을 가리키게 되고, `eq`가 1이면 `coef`와 `cons` 배열에서 우항을 가리키게 된다.)
    - 1-7. **`idx` 변수를 이용하여 방정식 문자열을 순회하면서 아래와 같은 과정을 수행**한다.
        - case 1. 만약 **문자열의 이번 인덱스 문자가 숫자라면, `num` 문자열에 이번 숫자를 문자열 뒤에 붙인다.**
        - case 2. 만약 **문자열의 이번 인덱스 문자가 'x'라면, 상수항임을 나타내는 `iscon` 변수를 false로 바꿔 이번 숫자는 계수항임을 나타낸다.**
        - case 3. 만약 **문자열의 이번 인덱스 문자가 숫자 또는 'x'가 아니라면, 조건에 따라 아래 작업을 수행**한다.
            - case 3-1. 만약 **이번 항이 상수항(`iscon` == true)이라면, `num`에 숫자 문자열이 저장되어 있는지 확인하고 숫자 문자열이 존재한다면 해당 숫자 문자열을 정수형으로 바꾼 후 양수/음수 조건에 따라 상수항 배열 `cons`에 더하거나 빼서 누적 저장**한다. 현재 좌항(`eq` == 0)이라면 좌항 원소(`cons[0]`)에 누적하고, 현재 우항(`eq` == 1)이라면 우항 원소(`cons[1]`)에 누적한다.
            - case 3-2. 만약 **이번 항이 계수항(`iscon` == false)이라면, 아래와 같이 `num`에 숫자 문자열이 저장되어 있는지 확인**한다. 
                - case 3-2-1. **`num`에 숫자 문자열이 존재한다면 해당 숫자 문자열을 정수형으로 바꾼 후 양수/음수 조건에 따라 계수항 배열 `coef`에 더하거나 빼서 누적 저장**한다. 현재 좌항(`eq` == 0)이라면 좌항 원소(`coef[0]`)에 누적하고, 현재 우항(`eq` == 1)이라면 우항 원소(`coef[1]`)에 누적한다.
                - case 3-2-2. **`num`에 숫자 문자열이 존재하지 않는다면 계수가 1이라는 의미이므로 양수/음수 조건에 따라 계수항 배열 `coef`에 1을 더하거나 빼서 누적 저장**한다. 현재 좌항(`eq` == 0)이라면 좌항 원소(`coef[0]`)에 1을 누적하고, 현재 우항(`eq` == 1)이라면 우항 원소(`coef[1]`)에 누적한다.
            - 위 조건에 따라 작업을 수행한 후, **문자열의 이번 인덱스 문자의 조건에 따라 아래와 같은 작업을 수행**한다.
                - case 3-A. **문자열의 이번 인덱스 문자가 '+'라면, 양수항임을 나타내는 `plus` 변수를 true로 바꾼다.**
                - case 3-B. **문자열의 이번 인덱스 문자가 '-'라면, 양수항임을 나타내는 `plus` 변수를 false로 바꾼다.**
                - case 3-C. **문자열의 이번 인덱스 문자가 '='라면, 우선 양수항임을 나타내는 `plus` 변수를 `true`로 초기화한 후,** 좌항에서 우항으로 바뀌었기 때문에 **항 인덱스 `eq`를 0에서 1로 바꿔준다.**
            - 위 조건식까지 수행한 후, **상수항임을 나타내는 변수 `iscon`을 true로 초기화해준 후, 숫자 문자열 `num`을 다시 빈 문자열로 초기화**해준다.
        - 모든 조건을 확인한 후 마지막으로 **`idx` 인덱스 변수를 1 올려준다.**
    - 1-8. 문자열 순회가 끝난 후, 마지막으로 **`num` 숫자 문자열에 남아있는 숫자를 조건에 따라 1-7 과정의 case 3-1 또는 case 3-2 과정을 수행하며 상수항 또는 계수항에 누적**한다.
    - 1-9. **누적된 계수항과 상수항을 각각 좌항과 우항으로 이항한 후, 좌항의 계수값을 `coefficient` 변수에 저장하고, 우항의 상수값을 `constant` 변수에 저장**한다.
    - 1-10. **조건에 따라 아래 과정을 수행하여 x의 값을 계산**한다.
        - case 1. 만약 **계수(`coefficient`)와 상수(`constant`)가 모두 0이라면,** 해가 무한하므로 **"IDENTITY"를 출력**한다.
        - case 2. 만약 **계수(`coefficient`)만 0이라면,** 해가 존재하지 않으므로 **"IMPOSSIBLE"을 출력**한다.  
        - case 3. 만약 **상수(`constant`)만 0이라면,** x가 0일 때에만 식이 참이 되므로 **0을 출력**한다.
        - case 4. **그 외의 경우, 상수(`constant`)을 계수(`coefficient`)로 나눈 몫을 `result` 변수에 저장**한다. 만약 **`result` 값이 음수이고, 나누어떨어지지 않는 값이라면 `result` 변수를 1 올린다.** (문제에서 결과값이 소수로 나왔을 때 몫이 아닌 내림 연산 결과를 요구하기 때문에 음수 소수값이 나왔을 때 별도의 내림 연산 처리가 필요하다.) 이후 **최종 `result` 값을 출력**한다.

#### 코멘트

또다시 등장한 파싱 문제로, 이번에는 괄호 없는 단순 일차방정식을 파싱하여 해를 구하는 문제이다.  
괄호가 없고 덧셈/뺄셈 연산만 있기 때문에 파싱 구현 자체는 크게 어렵진 않았다.  
다만 상수항과 계수항을 정리하고 이항하는 과정을 설계하기가 약간 까다로운 편이었다.  
  
첫 제출에서 오답이 나왔는데, 생각지도 못한 부분에 원인이 있었다.  
처음 구현에서는 단순히 소수 결과를 정수 몫으로 출력하는 방식으로 구현했었지만 문제에서는 내림(floor) 연산 결과를 요구하고 있었고, 결과가 음수일 때의 내림 연산은 정수 몫 연산 결과와 다르기 때문에 오답이 나오게 된 것이다.
이 부분을 처음에 전혀 예상하지 못하고 다른 데서 예외 케이스를 찾느라 삽질을 엄청나게 했다.  
결국 문제를 출제했던 ICPC 사이트(https://icpc.sharif.edu/2003/)를 직접 찾아서 테스트 데이터를 돌려본 후에야 겨우 원인을 파악할 수 있었다.  

---

## E
### #33553 : Floor Tiling
https://www.acmicpc.net/problem/33553

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## F
### #6002 : Job Hunt
https://www.acmicpc.net/problem/6002

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## G
### #22235 : 가희와 수인 분당선 1
https://www.acmicpc.net/problem/22235

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## H

### #25835 : Lots of Towers of Hanoi
https://www.acmicpc.net/problem/25835

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## 결과 및 후기

| A | B | C | D | E | F | G | H |
|---|---|---|---|---|---|---|---|
| ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ |

