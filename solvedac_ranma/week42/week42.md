# solved\.ac 랜덤 마라톤 42주차

<img src="./img/week42unsolved.PNG">

---

## A
### #24079 : 移動 (Moving)
https://www.acmicpc.net/problem/24079

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/2.svg' width='30'>

#### 사용 알고리즘

**#수학**  
**#사칙연산**  

#### 풀이

A 지점에서 B 지점까지의 소요시간과 B 지점에서 C 지점까지의 소요시간이 주어졌을 때 A 지점에서 B 지점을 거쳐 C 지점을 가는데 걸리는 소요시간이 Z시간 30분보다 작은지 판정하는 문제.

1. A 지점에서 B 지점까지의 소요시간 `x`, B 지점에서 C 지점까지의 소요시간 `y`, 비교할 시간 `z`를 입력받는다.
2. `x` + `y`의 값이 `z`보다 작다면 `0`을 출력하고, `x` + `y`의 값이 `z`보다 크거나 같다면 `1`을 출력한다.

#### 코멘트

단순한 덧셈 연산 후 조건식을 비교하는 사칙연산 문제이다. 브론즈4보다는 브론즈5에 더 가까운 수준의 난이도가 아닌가 싶다.  
  
뜬금없이 일본어 문제가 출몰해서 확인해봤더니 추천 받는 문제가 '일정 수듄' 이상이라며 더 이상 언어 편식을 못하게 막아놨다.  

<img src="./img/language.PNG">
  
뭐야 내 영어 및 한국어 문제 돌려줘요  

---

## B
### #27482 : Block Adventure
https://www.acmicpc.net/problem/27482

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/9.svg' width='30'>

#### 사용 알고리즘

**#그리디 알고리즘**  

#### 풀이

일렬로 각기 다른 높이를 가진 블록 탑을 차례대로 오르내리며 여분의 블록을 저장하고 꺼내는 과정을 통해 마지막 블록 탑에 도달할 수 있는지 파악하는 문제.

1. **테스트 케이스 개수 `t`를 입력받아 아래 과정을 `t`번 반복**한다.
    - 1-1. **블록 탑 개수 `n`, 초기 여분 블록 `m`, 넘을 수 있는 블록 높이 `k` 변수를 선언하여 입력받는다.**
    - 1-2. **블록을 넘을 수 있는지 여부를 판정할 bool 변수 `valid`를 선언하고 true로 초기화**한다.
    - 1-3. **`prev` 변수를 선언한 후 첫 번째 블록 탑의 높이를 입력받아 저장**한다.
    - 1-4. **두 번째 탑부터 `n`번째 탑까지 아래 과정을 반복**한다.
        - 1-4-1. **이번 탑의 높이 `h`를 입력받은 후 조건에 따라 아래 과정을 수행**한다.
            - case 1. 만약 **이번 탑의 높이가 이전 탑에서 넘을 수 있는 높이 이상(`prev` + `k` ≤ `h`)이라면, 조건에 따라 아래 과정을 수행**한다.
                - case 1-1. 만약 **여분의 블록을 모두 사용해도 이번 탑 높이에 도달할 수 없다면(`prev` + `k` + `m` < `h`)**, 더 이상 탑을 통과할 수 없으므로 **`valid` 변수를 false로 바꾼다.**
                - case 1-2. 만약 **여분 블록을 사용해서 이번 탑 높이에 도달할 수 있다면, 여분 블록 `m`에서 필요한 만큼 블록을 제거**한다.
            - case 2. 만약 **이번 탑의 높이가 이전 탑에서 넘을 수 있는 높이 미만이라면, 이번 블록을 넘기 위한 최소 높이(max(0, `h` - `k`))를 계산한 뒤**, 이전 탑 높이와 최소 높이의 차를 통해 **이전 탑에서 빼낼 수 있는 최대 블록 개수를 구해서 여분 블록 `m`에 추가**한다.
        - 1-4-2. **이전 탑 높이 `prev` 값을 이번 탑 높이 `h` 값으로 바꾼다.**
    - 1-5. 모든 탑을 순회한 후 **`valid` 변수가 true라면** 마지막 탑까지 도달할 수 있다는 뜻이므로 **"YES"를 출력**한다. 만약 **false라면 "NO"를 출력**한다.
  
블록 탑을 넘어가기 위해 필요한 최소 높이를 계산한 뒤, 여분으로 저장할 수 있는 블록은 남기지 말고 최대한 저장하는 그리디 알고리즘으로 해결 가능한 문제이다.  

#### 코멘트

발상 자체는 어렵지 않은 그리디 문제이다.  
블록을 남기고 간다고 해서 이후 과정에 끼치는 영향이 전혀 없기 때문에 가져갈 수 있는 블록은 최대한 가져가는 것이 핵심이다.  
  
오히려 발상보다는 구현이 더 까다로웠는데, 넘을 수 있는 최소 높이를 계산하는 과정에서 음수가 되어버리거나, 이전 타워의 높이가 0인데 나올리가 없는 여분의 블록을 저장하는 등 생각치 못한 예외 조건들이 튀어나와서 오답이 2번이나 나왔다.  
알고리즘 풀이를 쉽게 떠올렸다고 만만하게 구현했다가 큰 코 다친 문제이다.  
  
여분 블록을 저장하면서 오버플로우가 나지 않을까 쫄았는데 각 블록 탑의 최대 높이가 $10^{6}$이고, 탑의 최대 개수가 100($10^{2}$)이기 때문에 저장할 수 있는 최대 여분 블록은 $10^{8}$로 int형 변수 범위로 커버할 수 있었다.

---

## C
### #26580 : Rain
https://www.acmicpc.net/problem/26580

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/11.svg' width='30'>

#### 사용 알고리즘

**#구현**  
**#시뮬레이션**  

#### 풀이

높이가 각각 다른 여러 개의 칸으로 이루어진 1차원 배열 형태의 빗물받이통에 모을 수 있는 빗물의 양을 계산하는 문제.

1. 계산할 **빗물받이 통 개수 `n`을 입력받는다.** (이후 공백 포함 문자열을 받기 위한 getline() 함수를 사용하기 위해 cin.ignore() 함수를 실행한다.)
2. 빗물받이 통의 개수 **`n`만큼 아래 과정을 반복하며 받을 수 있는 빗물의 양을 계산**한다.
    - 2-1. **빗물받이 통 정보를 문자열로 받은 후, 각각의 숫자를 추출하여 빗물받이 통의 각 칸 높이를 배열 `v`에 저장**한다.
    - 2-2. **빗물의 양을 누적할 `total` 변수를 선언하고 0으로 초기화**한다.
    - 2-3. 빗물받이 배열 **`v`의 두 번째 배열부터 마지막 두 번째 까지의 원소를 반복(`v[i]`)하며 아래 과정을 통해 각 칸에서 모을 수 있는 빗물의 최대 양을 계산**한다. (첫 번째 원소와 마지막 원소 위치에서는 옆이 뚫려있기 때문에 빗물을 모을 수 없다.)
        - 2-3-1. **현재 칸 위치 인덱스 `i`를 기준으로 좌측과 우측에 위치한 원소 중 가장 큰 높이를 저장할 변수 `lmax`, `rmax`를 선언하고 -1000000001로 초기화**한다. (각 원소는 최소 -1000000000까지 저장될 수 있다.)
        - 2-3-2. **현재 칸 위치 인덱스 `i`를 기준으로 좌측의 모든 원소를 순회하며 가장 높은 높이를 `lmax`에 저장**한다.
        - 2-3-3. **현재 칸 위치 인덱스 `i`를 기준으로 우측의 모든 원소를 순회하며 가장 높은 높이를 `rmax`에 저장**한다.
        - 2-3-4. 만약 **`lmax`와 `rmax`가 `v[i]`보다 크다면,** `i` 위치에는 `lmax`와 `rmax` 높이에 의해 물이 저장될 수 있다는 의미이므로, **모을 수 있는 물의 양인 min(`lmax`, `rmax`) - `v[i]`를 `total`에 누적**한다. (만약 `lmax` 또는 `rmax`가 `v[i]`보다 크지 않다면 `i` 위치에서는 물을 가둘 수 있는 높이가 충족되지 않아 `i` 위치에서 물이 모이지 못하고 빗물받이 통 밖으로 흘러넘칠 것이다.)
    - 2-5. **누적된 `total` 값을 출력**한다.

모을 수 있는 빗물의 양이 최대 $28 × 10^{9}$로 int 범위를 초과하기 때문에, **long long 등의 범위가 큰 타입을 사용해야 오버플로우를 방지할 수 있다.**  

#### 코멘트

오랜만에 등장한 순수 구현 문제이다. 그렇다고 머리를 쥐어짜야 할 수준의 빡구현 문제까지는 아니고 나름 어렵다면 어려울 수 있는데, 또 쉽다고 생각한다면 쉬운 해괴한 난이도의 문제이다.  

문제 자체는 나쁘지 않은데, 풀이 외적인 요소가 매우 불친절하여 썩 마음에 들진 않았던 문제이다.  
빗물받이 통 배열 크기를 입력받지 않고 한 줄의 문자열로 입력받는 형식이라 C++로 풀 때 별도의 파싱 과정이 필요했으며  
무엇보다 배열 크기 `n`이랑 배열 원소 크기의 범위가 제공되지 않아서 최적화가 얼마나 필요한지 문제 지문만으로는 전혀 알 수 없었다.  
다행히 게시판에 어떤 친절한 분이 자체적으로 문제 제한을 조사해놓은 걸 참고해서 풀 수 있었지만 문제를 풀기도 전부터 상당한 불쾌함을 안고 시작했다.  

문제를 처음 읽고 나서는 뭔가 히스토그램 문제처럼 모노톤 스택을 이용해서 최적화를 해야 하나 싶어서 코드를 좀 짜봤는데, 모노톤 스택으로 구현하려니 생각보다 따져야 할 게 많고 로직이 산으로 가는 것 같아서 폐기했다.  
게시판을 보고 제한이 배열 크기 제한이 30이라는 것을 파악한 후에는 그냥 나이브한 $O(n^{2})$ 브루트포스로 풀기로 가닥을 잡고 풀이를 구현하였다.  
이것도 한동안 스택스러운 풀이에 매몰되는 바람에 풀이가 쓸데없이 복잡해지고 무수한 예외 상황이 생기자 풀이를 다시 갈아엎어서 단순화한 게 최종 코드이다.  
  
문제를 조금만 더 단순하게 생각했다면 훨씬 쉽게 풀었을 것 같은데 괜히 쓸데없는 고생을 한 기분이다.  

---

## D
### #7308 : A DP Problem
https://www.acmicpc.net/problem/7308

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/12.svg' width='30'>

#### 사용 알고리즘

**#수학**  
**#문자열**  
**#파싱**  

#### 풀이

주어진 일차방정식 문자열의 해를 구하는 문제.  

1. **테스트 케이스 개수 `t`를 입력받은 후 `t`번의 테스트 케이스를 아래와 같이 수행**한다.
    - 1-1. **일차방정식 문자열 `str`을 입력**받는다.
    - 1-2. **방정식에서 숫자 부분을 저장할 `num` 문자열을 선언하고 빈 문자열로 초기화**한다.
    - 1-3. **방정식 문자열을 순회하기 위한 인덱스 변수 `idx`를 선언하고 0으로 초기화한 후, 방정식 문자열의 크기 변수 `size`를 선언하여 방정식 문자열 크기를 저장**한다.
    - 1-4. **계수가 아닌 상수인지 여부를 판단하기 위한 bool 변수 `iscon`을 선언하여 true로 초기화하고, 양수인지 여부를 판단하기 위한 bool 변수 `plus`를 선언하고 true로 초기화**한다.
    - 1-5. **좌항과 우항의 계수를 저장할 2 크기의 `coef` 배열을 선언하고, 좌항과 우항의 상수를 저장할 2 크기의 `cons` 배열을 선언**한다. (`coef[0]`과 `cons[0]`은 각각 좌항의 계수와 상수를 나타내고, `coef[1]`과 `cons[1]`은 각각 우항의 계수와 상수를 나타낸다.)
    - 1-6. **현재 식이 좌항인지, 우항인지 나타낼 정수형 변수 `eq`를 선언하고 0으로 초기화**한다. (`eq`가 0이면 좌항, 1이면 우항임을 나타낸다. 이는 인덱스의 역할을 수행하여 `eq`가 0이면 `coef`와 `cons` 배열에서 좌항을 가리키게 되고, `eq`가 1이면 `coef`와 `cons` 배열에서 우항을 가리키게 된다.)
    - 1-7. **`idx` 변수를 이용하여 방정식 문자열을 순회하면서 아래와 같은 과정을 수행**한다.
        - case 1. 만약 **문자열의 이번 인덱스 문자가 숫자라면, `num` 문자열에 이번 숫자를 문자열 뒤에 붙인다.**
        - case 2. 만약 **문자열의 이번 인덱스 문자가 'x'라면, 상수항임을 나타내는 `iscon` 변수를 false로 바꿔 이번 숫자는 계수항임을 나타낸다.**
        - case 3. 만약 **문자열의 이번 인덱스 문자가 숫자 또는 'x'가 아니라면, 조건에 따라 아래 작업을 수행**한다.
            - case 3-1. 만약 **이번 항이 상수항(`iscon` == true)이라면, `num`에 숫자 문자열이 저장되어 있는지 확인하고 숫자 문자열이 존재한다면 해당 숫자 문자열을 정수형으로 바꾼 후 양수/음수 조건에 따라 상수항 배열 `cons`에 더하거나 빼서 누적 저장**한다. 현재 좌항(`eq` == 0)이라면 좌항 원소(`cons[0]`)에 누적하고, 현재 우항(`eq` == 1)이라면 우항 원소(`cons[1]`)에 누적한다.
            - case 3-2. 만약 **이번 항이 계수항(`iscon` == false)이라면, 아래와 같이 `num`에 숫자 문자열이 저장되어 있는지 확인**한다. 
                - case 3-2-1. **`num`에 숫자 문자열이 존재한다면 해당 숫자 문자열을 정수형으로 바꾼 후 양수/음수 조건에 따라 계수항 배열 `coef`에 더하거나 빼서 누적 저장**한다. 현재 좌항(`eq` == 0)이라면 좌항 원소(`coef[0]`)에 누적하고, 현재 우항(`eq` == 1)이라면 우항 원소(`coef[1]`)에 누적한다.
                - case 3-2-2. **`num`에 숫자 문자열이 존재하지 않는다면 계수가 1이라는 의미이므로 양수/음수 조건에 따라 계수항 배열 `coef`에 1을 더하거나 빼서 누적 저장**한다. 현재 좌항(`eq` == 0)이라면 좌항 원소(`coef[0]`)에 1을 누적하고, 현재 우항(`eq` == 1)이라면 우항 원소(`coef[1]`)에 누적한다.
            - 위 조건에 따라 작업을 수행한 후, **문자열의 이번 인덱스 문자의 조건에 따라 아래와 같은 작업을 수행**한다.
                - case 3-A. **문자열의 이번 인덱스 문자가 '+'라면, 양수항임을 나타내는 `plus` 변수를 true로 바꾼다.**
                - case 3-B. **문자열의 이번 인덱스 문자가 '-'라면, 양수항임을 나타내는 `plus` 변수를 false로 바꾼다.**
                - case 3-C. **문자열의 이번 인덱스 문자가 '='라면, 우선 양수항임을 나타내는 `plus` 변수를 `true`로 초기화한 후,** 좌항에서 우항으로 바뀌었기 때문에 **항 인덱스 `eq`를 0에서 1로 바꿔준다.**
            - 위 조건식까지 수행한 후, **상수항임을 나타내는 변수 `iscon`을 true로 초기화해준 후, 숫자 문자열 `num`을 다시 빈 문자열로 초기화**해준다.
        - 모든 조건을 확인한 후 마지막으로 **`idx` 인덱스 변수를 1 올려준다.**
    - 1-8. 문자열 순회가 끝난 후, 마지막으로 **`num` 숫자 문자열에 남아있는 숫자를 조건에 따라 1-7 과정의 case 3-1 또는 case 3-2 과정을 수행하며 상수항 또는 계수항에 누적**한다.
    - 1-9. **누적된 계수항과 상수항을 각각 좌항과 우항으로 이항한 후, 좌항의 계수값을 `coefficient` 변수에 저장하고, 우항의 상수값을 `constant` 변수에 저장**한다.
    - 1-10. **조건에 따라 아래 과정을 수행하여 x의 값을 계산**한다.
        - case 1. 만약 **계수(`coefficient`)와 상수(`constant`)가 모두 0이라면,** 해가 무한하므로 **"IDENTITY"를 출력**한다.
        - case 2. 만약 **계수(`coefficient`)만 0이라면,** 해가 존재하지 않으므로 **"IMPOSSIBLE"을 출력**한다.  
        - case 3. 만약 **상수(`constant`)만 0이라면,** x가 0일 때에만 식이 참이 되므로 **0을 출력**한다.
        - case 4. **그 외의 경우, 상수(`constant`)을 계수(`coefficient`)로 나눈 몫을 `result` 변수에 저장**한다. 만약 **`result` 값이 음수이고, 나누어떨어지지 않는 값이라면 `result` 변수를 1 올린다.** (문제에서 결과값이 소수로 나왔을 때 몫이 아닌 내림 연산 결과를 요구하기 때문에 음수 소수값이 나왔을 때 별도의 내림 연산 처리가 필요하다.) 이후 **최종 `result` 값을 출력**한다.

#### 코멘트

또다시 등장한 파싱 문제로, 이번에는 괄호 없는 단순 일차방정식을 파싱하여 해를 구하는 문제이다.  
괄호가 없고 덧셈/뺄셈 연산만 있기 때문에 파싱 구현 자체는 크게 어렵진 않았다.  
다만 상수항과 계수항을 정리하고 이항하는 과정을 설계하기가 약간 까다로운 편이었다.  
  
첫 제출에서 오답이 나왔는데, 생각지도 못한 부분에 원인이 있었다.  
처음 구현에서는 단순히 소수 결과를 정수 몫으로 출력하는 방식으로 구현했었지만 문제에서는 내림(floor) 연산 결과를 요구하고 있었고, 결과가 음수일 때의 내림 연산은 정수 몫 연산 결과와 다르기 때문에 오답이 나오게 된 것이다.
이 부분을 처음에 전혀 예상하지 못하고 다른 데서 예외 케이스를 찾느라 삽질을 엄청나게 했다.  
결국 문제를 출제했던 ICPC 사이트(https://icpc.sharif.edu/2003/)를 직접 찾아서 테스트 데이터를 돌려본 후에야 겨우 원인을 파악할 수 있었다.  

---

## E
### #33553 : Floor Tiling
https://www.acmicpc.net/problem/33553

#### 해결 상태
✅

#### 난이도
<img src='https://static.solved.ac/tier_small/12.svg' width='30'>

#### 사용 알고리즘

**#다이나믹 프로그래밍**
**#임의 정밀도 / 큰 수 연산**

#### 풀이

3×2n 크기의 공간 전체를 2×1 크기의 타일로 채우는 경우의 수를 구하는 문제.

1. 타일을 채울 공간의 너비 절반 값 `n`을 입력받는다.
2. `dp` 배열을 선언한 후, dp[0]에 1을, dp[1]에 3을 저장한다. (`n`이 0일 때 경우의 수는 타일이 아무것도 채워지지 않은 공집합 1개이고, `n`이 1일 때 타일을 채우는 경우의 수는 3이다.)
3. 누적값을 저장할 `sum` 변수를 선언하고 0으로 초기화한다.
4. `dp` 배열의 세 번째 원소(`dp[2]`)부터 `n` + 1번째 원소(`dp[n]`)까지 `i`번째 원소에 대하여 아래 과정을 거친다.
    - 4-1. 먼저 `dp[i]`에 `dp[1]`(3) × `dp[i - 1]` 값을 더해준다.
    - 4-2. `sum`에 2 * `dp[i - 2]` 값을 곱한 값을 더하여 누적하고, `dp[i]`에 `sum`을  더하여 누적한다.
5. `dp[n]`의 값을 출력한다.

계산 결과값이 엄청나게 커지기 때문에(C++의 long long 타입도 아득히 초과한다!) 파이썬으로 큰 수 연산을 날먹해서 해결하였다.  
Life is Short, you need Python.  

##### 풀이 부록

점화식을 설정하는 과정은 다음과 같다.  

먼저 **n = 0**일 때, 아무것도 채우지 않는 공집합 1개의 경우의 수가 존재한다고 표현할 수 있다.  

**n = 1**일 때, 아래 그림과 같이 3개의 경우의 수가 존재한다.  

<img src="./img/33553/n1.png">

**n >= 2** 인 경우부터는, 모양을 이루는 타일이 분할되지 않고 정확히 3×2n 크기로 구성될 수 있는 경우의 수가 아래 그림과 같이 각각 2개씩 존재한다.

<img src="./img/33553/nopartition.png">

따라서, 3×2n 크기의 타일을 채울 수 있는 경우의 수는 너비 2칸 단위로 공간을 좌/우로 분할하는 경우의 수로 나누어 생각해볼 수 있다.  
  
예를 들어 **n = 2**(3 × 4 크기)의 경우,

<img src="./img/33553/n2.png">

위 그림과 같이 좌/우를 2/2 (n 기준 1/1)크기로 분할하는 경우와 4/0 (n 기준 2/0)크기로 분할하는 경우로 나눌 수 있다.  

- 2/2로 분할 했을 때의 경우의 수는 n = 1일 때 경우의 수를 독립적으로 체크하면 되므로 3 × 3 = 9가 된다.
- 4/0로 분할 했을 때에는 왼쪽 블록을 분할 했을 때 2/2의 경우의 수와 중복이 되기 때문에 3
×4 크기의 분할되지 않는 경우의 수를 사용하여야 한다. 그런데 `n >= 2`일 때 분할되지 않는 경우의 수는 위에서 확인했듯이 모두 2이다. 따라서 분할되지 않는 너비 4 경우의 수(2)와 너비 0 경우의 수(공집합 1)을 곱하면 4/0 분할 경우의 수는 2가 된다.
  
위 케이스들을 모두 합하면 n = 2일 때 경우의 수는 11이다.

같은 방식으로 **n = 3**(3 × 6 크기)의 경우,

<img src="./img/33553/n3.png">

- 2/4로 분할 했을 때 경우의 수는 3×2 경우의 수(3)와 3×4 경우의 수(11)의 곱(33)이다.
- 4/2로 분할 했을 때 중복을 제외한 경우의 수는 분할되지 않는 3×4 경우의 수(2)와 3×2 경우의 수(3)의 곱(6)이다.
- 6/0으로 분할 했을 때 중복을 제외한 경우의 수는 분할되지 않는 3×6 경우의 수(1)와 3×0 경우의 수(1)의 곱(2)이다.
다 더하면 41이 나온다.

**n = 4**일 때도 동일한 방식으로 구할 수 있다.
<img src="./img/33553/n4.png">
  
이를 일반화해보면, n일 때 경우의 수는 ({너비가 2일 때 경우의 수} × {너비가 n - 2일 때 경우의 수})와 ($2\sum_{i=2}^{n}{{}}${너비가 $n - 2i$일 때 경우의 수})의 합이라는 것을 알 수 있다.
즉, 아래와 같은 DP 점화식 테이블을 얻을 수 있다.  
<img src="./img/33553/table.png">

위 점화식에 따라 1차원 DP를 이용하여 적절하게 코드를 구현하면 된다.

#### 코멘트

꽤나 까다로운 DP 문제였다. 
특히 경우의 수를 계산하면서 중복 케이스를 놓치는 일이 많아서 이를 배제하는 방법을 찾느라 골치를 꽤나 썩였다.  
결국 너비 2칸 단위로 공간을 좌/우로 나누는 경우의 수로 분할하고, 좌측 부분에 해당하는 공간은 분할이 불가능하도록 구성하여 중복 없이 경우의 수를 깔끔하게 구분할 수 있었다.  
와중에 연산 과정에서 수가 무지막지하게 커지기 때문에 C++ 대신 파이썬으로 큰 수 연산을 해결하였다.  

처음에는 이전 인덱스까지의 합을 일일이 2 ~ i-1 범위 for문을 돌려 구했는데, 점화식을 정리해보니 그냥 누적변수 하나를 선언해서 각 인덱스 값을 더하는 방식으로 최적화하였다.  
그 결과 시간복잡도를 $O(n^{2})$에서 $O(n)$으로 줄였지만 어차피 n의 범위가 최대 100이라서 $O(n^{2})$ 구현도 통과되기는 하였다.  


이 문제는 옛날에 프로그래머스 코딩 테스트 연습문제에서 봤던 기억이 있다.  
https://school.programmers.co.kr/learn/courses/30/lessons/12902
예전에 프로그래머스 문제를 열심히 풀다가 이 문제에 막혀서 손을 놨었는데, 이번에 해결한 기념으로 프로그래머스도 재개해볼까 하는 생각이 든다.   


---

## F
### #6002 : Job Hunt
https://www.acmicpc.net/problem/6002

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## G
### #22235 : 가희와 수인 분당선 1
https://www.acmicpc.net/problem/22235

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## H

### #25835 : Lots of Towers of Hanoi
https://www.acmicpc.net/problem/25835

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트


---

## 결과 및 후기

| A | B | C | D | E | F | G | H |
|---|---|---|---|---|---|---|---|
| ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ |

