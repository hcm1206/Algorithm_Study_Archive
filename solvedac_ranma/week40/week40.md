# solved\.ac 랜덤 마라톤 40주차

<hr>

## A
### #21638 : SMS from MCHS
https://www.acmicpc.net/problem/21638

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/2.svg' width='30'>

#### 사용 알고리즘

**#구현**

#### 풀이

if-else 문을 이용한 단순 조건문 비교 구현 문제.  
1. 만약(`if`) **내일 기온 $t_2$가 0 미만이고 내일 풍속 $v_2$가 10 이상**이면 폭풍 알림 문자열을 출력한다.  
2. 그렇지 않고(`else if`) **내일 기온 $t_2$가 오늘 기온 $t_2$보다 작다면** 낮은 기온 경고 알림 문자열을 출력한다.  
3. 그렇지 않고(`else if`) **내일 풍속 $v_2$가 오늘 풍속 $v_1$보다 크다면** 강풍 경고 알림 문자열을 출력한다.  
4. **위 모든 경우에 해당하지 않으면**(`else`) 보낼 메시지가 없다고 출력한다.  

#### 코멘트

영어 지문이 쓸데없이 길어서 귀찮았던 것 빼면 A번 답게 무난했다.  

다만 예제 출력1 부분에 
```
MCHS warns! Low temperature
is expected tomorrow.
```
위와 같이 임의로 문자열이 개행되어 있어서 좀 당황했는데, 문제 출력 부분 설명을 다시 읽어보니
```
You can separate message words with spaces and line feeds arbitrarily.
(출력되는 메시지의 단어들은 공백 또는 줄바꿈 문자로 자유롭게 구분될 수 있다.)
```
가 적혀있었다.   
무슨 원리인진 모르겠지만 그냥 줄바꿈 안 하고 출력했더니 통과되었다.  
역시 지문은 꼼꼼하게 읽어야 한다는 교훈을 $N$번째 재확인하게 되었다. ($1 \leq N \leq 10^9$)  


<hr>

## B
### #15270 : 친구 펠린드롬
https://www.acmicpc.net/problem/15270

#### 해결 상태
❌

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## C
### #13348 : Memory Match
https://www.acmicpc.net/problem/13348

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/10.svg' width='30'>

#### 사용 알고리즘

**#구현**  
**#많은 조건 분기**  

#### 풀이

카드 짝 맞추기 게임 구현 문제.  
주어진 조건과 게임 진행 상황을 기준으로 현재 상황에서 찍지 않고 확정적으로 짝을 맞출 수 있는 카드 쌍의 개수를 구하는 문제이다.  

1. 카드 종류(문자열)와 해당 종류 카드들의 위치 정보(정수)를 저장하는 map 자료구조 `cards`를 선언하고, 누군가가 짝을 맞춰서 앞면으로 표시된 카드 종류(문자열)를 저장하기 위한 set 자료구조 `faceups`를 선언한다.  
2. k번의 반복을 통해 게임 진행 상황을 입력받으면서 카드들의 위치 정보를 `cards`(map)에 저장한다. 카드 종류 문자열을 key로 저장하고, 카드 위치(인덱스) 정보를 value에 저장된 set의 원소로 추가한다.
    - case 1. 만약 게임 진행 중 누군가 카드 짝을 맞춘 경우가 생긴다면(입력받은 카드 종류 p1과 p2가 같다면) `faceups`(set)에 해당 카드 종류를 추가하고, 현재 남은 뒷면 카드 수(`n`)에서 2를 뺀다.
3. 이제 현재 상황에서 확정적으로 짝지을 수 있는 카드 쌍의 개수를 나타내는 변수 score를 선언하고, 정보가 드러난 카드 개수를 나타내는 revealed 변수를 선언하여 두 변수를 모두 0으로 초기화한다.
4. map 자료구조에 저장된 카드 위치 정보를 순회한다.
    - case 1. 만약 어떤 카드 위치(value set)에 2개의 위치 정보(원소)가 저장되어 있고, 해당 카드가 아직 아무도 맞추지 않아서 앞면으로 표시되지 않았다면(value set에 존재하지 않는다면) 해당 카드는 확정적으로 짝을 지을 수 있으므로 `score` 변수를 1 올리고 남은 뒷면 카드 수(n)에서 2를 뺀다.
    - case 2. 만약 어떤 카드 위치(value set)에 1개의 위치 정보(원소)가 저장되어 있다면 정보가 드러낸 카드 개수 `revealed` 변수를 1 올린다.
5. 이제 남은 뒷면 카드 개수(`n`) 중에서 정보를 알고 있는 카드 개수(`revealed`)에 따라 추가로 짝 지을 수 있는 카드 개수를 계산한다.
    - case 1. 만약 남은 뒷면 카드 개수(`n`)가 2개라면, 그 2개 카드는 무조건 똑같은 종류의 카드이므로 score에 1을 추가한다.
    - case 2. 만약 남은 뒷면 카드 개수(`n`) 중에서 정보가 밝혀진 카드 개수(`revealed`)가 절반 이상이라면(`n <= revealed * 2`), 아직 밝혀지지 않은 카드 중 어떤 것을 선택해도 짝이 맞는 카드의 위치를 알 수 있기 때문에 남은 카드들을 모두 짝지을 수 있다. 따라서 score에 revealed 변수 값을 그대로 더하면 된다. (조건문은 저렇게 되어 있지만 구조 상 revealed 변수는 n의 절반값을 초과할 수 없기 때문에 revealed는 항상 남은 뒷면 카드 수 n의 절반이 된다.)
6. 계산된 짝지을 수 있는 카드 쌍 개수(`score`)를 출력한다.

#### 코멘트

문제 내용 자체는 우리가 흔히 하는 카드 짝 맞추기 게임과 똑같아서 이해하기 쉬웠으나 생각보다 구현하기 까다로웠다.  
특히 남은 카드 정보를 통해 확정적으로 짝지을 수 있는 케이스들을 모두 파악하는 과정이 쉽지 않은 문제이다.  

풀이가 좀 난잡하게 구현된데다가 반례도 꼼꼼하게 확인하지 못해서 2번이나 틀렸다.  
처음에는 남은 뒷면 카드가 2개일 때 확정적으로 짝지을 수 있다는 케이스를 놓쳐서(5번 풀이의 case 1 부분) 틀렸다.  
그래서 조건문으로 n <= 2일 때 score를 1 올리는 코드를 추가하였는데, 이 경우 남은 카드가 없을 때(n == 0)에도 score를 1 올려버리기 때문에 또 문제가 되었다.  
다시 조건문을 n == 2로 바꾼 후에야 겨우 AC를 받았다.  

제출된 코드에 facedown 이라는 변수가 선언되어 있는데 디버깅하는 과정에서 추가해놓고 정작 사용하지 않았다.  

<hr>

## D
### #5369 : Asteroid Field
https://www.acmicpc.net/problem/5369

#### 해결 상태
❌

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## E
### #24411 : Stamp Combinations
https://www.acmicpc.net/problem/24411

#### 해결 상태
❌

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## F
### #17471 : 게리맨더링
https://www.acmicpc.net/problem/17471

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## G
### #31228 : 실 전화기
https://www.acmicpc.net/problem/31228

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## H
### #3936 : Molecular Formula 
https://www.acmicpc.net/problem/3936

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/15.svg' width='30'>

#### 사용 알고리즘

**#구현**  
**#자료 구조**  
**#문자열**  
**#트리를 사용한 집합과 맵**  
**#파싱**  
**#스택**  
**#재귀**  
**#해싱**  

#### 풀이

문제에서 원자 종류와 원자량, 그리고 분자식이 주어지고 분자식에 따라 주어진 원자만으로 분자를 구성할 수 있는지 여부를 검증한 후, 구성할 수 있다면 해당 분자의 총 원자량을 계산하는 문제.  
  
1. 먼저 **map 자료구조를 생성**하고 무한루프를 돌려 **입력받는 원자의 원자 기호(문자열)과 원자량(정수)을 저장**한다. "END_OF_FIRST_PART"가 입력되면 원자 입력 루프문을 종료한다.
2. 다음으로 또 무한루프를 돌려 **분자식을 문자열로 입력**받는다. 입력받은 문자열이 "0"이면 분자식 입력 루프문을 종료한다.
    - 2-1. 원자량을 계산하는데 필요한 여러가지 변수들을 선언한다.  
        - 2-1-1. 현재까지의 누적된 총 원자량을 나타낼 변수 **sum**을 선언하여 0으로 초기화한다. 
        - 2-1-2 분자식 문자열을 순회하기 위한 인덱스 변수 **idx**를 선언하여 0으로 초기화한다.
        - 2-1-3. 괄호 연산을 처리하기 위한 정수 스택 **st**를 선언한다.
        - 2-1-4. 유효한 분자식인지를 검증할 bool 변수 **valid**를 선언하고 일단 true로 초기화해놓는다.
    - 2-2. **분자식 문자열을 idx 변수로 순회**하면서 아래와 같은 과정을 거친다.
        - case 1. **여는 괄호('(')가 나왔다면** 지금까지 누적된 원자량 **(sum) 값을 스택에 보존**하고 이번 괄호 안의 누적 원자량 값을 저장하기 위해 **sum을 0으로 초기화**한다.
        - case 2. **닫는 괄호(')')가 나왔다면** 뒤에 숫자가 나오는지 확인한다. 
            - case 2-1. **숫자가 있다면** 숫자가 얼마인지 파악하여 괄호 안에서의 원자량 누적값 **sum에 숫자만큼 곱해준다.** 그 이후 스택에 보존되어 있는 **괄호 밖의 누적값(st.top())과 괄호 안의 누적값(sum)을 합쳐서 sum 변수에 저장**한다. **사용한 스택 값은 제거**한다. 
            - case 2-2. **숫자가 없다면** 위 과정을 sum에 곱하는 과정 없이 **바로 스택 값과 sum 값을 더해준 후 사용한 스택 값을 제거**한다.
        - case 3. **영어 대문자가 나왔다면** 원자를 나타내는 것이므로 **원자 기호를 파악**한다. **뒤의 문자가 소문자이면 뒤의 문자까지 포함하여 원자 기호를 구성**해준다.
            - case 3-1. **만약 원자 구성이 map에 존재하지 않는다면** 선언되지 않은 원자이므로 원자량을 계산할 수 없다. **검증 변수(valid)를 false로 바꾸고 분자식 문자열 순회를 종료**한다. 
            - case 3-2 **원자 구성이 map에 존재한다면** 해당 원자의 원자량 값을 map에서 가져온다. 그리고 분자식 뒤에 숫자가 붙어있다면 해당 숫자를 파악해서 **원자량 값을 뒤의 숫자만큼 곱해주고, 곱한 값을 원자량 누적값 sum에 더해준다.**
    - 2-3 어떤 식으로든 문자열 순회가 종료된 후에, **검증 변수가 false이면** 원자량을 알 수 없다는 의미의 **"UNKNOWN" 문자열을 출력**하고, **검증 변수가 true이면** 입력된 분자식에 대하여 계산된 **원자량 누적 값(sum)을 출력**한다.


#### 코멘트

최초로 랜덤 마라톤에서 골드 1 문제를 해결해버렸다.  
이딴 게 골드 1? 개인적으로 좀 많이 과대평가된 난이도 같다.  
  
지문에 웬 화학식이 나와서 쫄았으나, 문제 지문을 찬찬히 읽고 예제를 분석하니 감이 좀 잡혔다.  
문자열 파싱부터 시작해서 스택 & 맵 자료구조를 응용하고, 약간의 구현 요소를 짬뽕해놓은 문제이다.  
잡기술이 많이 들어가고 문자열 순회할 때 인덱스 처리가 좀 많이 골치아팠던 것 외에는 생각보다 할 만한 문제였다.  
알고리즘에 재귀가 들어가 있는데 나는 스택으로 해결했기 때문에 재귀는 안 썼다.  

