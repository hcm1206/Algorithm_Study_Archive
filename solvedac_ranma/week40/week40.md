# solved\.ac 랜덤 마라톤 40주차

<hr>

## A
### #21638 : SMS from MCHS
https://www.acmicpc.net/problem/21638

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/2.svg' width='30'>

#### 사용 알고리즘

**#구현**

#### 풀이

if-else 문을 이용한 단순 조건문 비교 구현 문제.  
1. 만약(`if`) **내일 기온 $t_2$가 0 미만이고 내일 풍속 $v_2$가 10 이상**이면 폭풍 알림 문자열을 출력한다.  
2. 그렇지 않고(`else if`) **내일 기온 $t_2$가 오늘 기온 $t_2$보다 작다면** 낮은 기온 경고 알림 문자열을 출력한다.  
3. 그렇지 않고(`else if`) **내일 풍속 $v_2$가 오늘 풍속 $v_1$보다 크다면** 강풍 경고 알림 문자열을 출력한다.  
4. **위 모든 경우에 해당하지 않으면**(`else`) 보낼 메시지가 없다고 출력한다.  

#### 코멘트

영어 지문이 쓸데없이 길어서 귀찮았던 것 빼면 A번 답게 무난했다.  

다만 예제 출력1 부분에 
```
MCHS warns! Low temperature
is expected tomorrow.
```
위와 같이 임의로 문자열이 개행되어 있어서 좀 당황했는데, 문제 출력 부분 설명을 다시 읽어보니
```
You can separate message words with spaces and line feeds arbitrarily.
(출력되는 메시지의 단어들은 공백 또는 줄바꿈 문자로 자유롭게 구분될 수 있다.)
```
가 적혀있었다.   
무슨 원리인진 모르겠지만 그냥 줄바꿈 안 하고 출력했더니 통과되었다.  
역시 지문은 꼼꼼하게 읽어야 한다는 교훈을 $N$번째 재확인하게 되었다. ($1 \leq N \leq 10^9$)  


<hr>

## B
### #15270 : 친구 펠린드롬
https://www.acmicpc.net/problem/15270

#### 해결 상태
❌

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## C
### #13348 : Memory Match
https://www.acmicpc.net/problem/13348

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/10.svg' width='30'>

#### 사용 알고리즘

**#구현**  
**#많은 조건 분기**  

#### 풀이

카드 짝 맞추기 게임 구현 문제.  
주어진 조건과 게임 진행 상황을 기준으로 현재 상황에서 찍지 않고 확정적으로 짝을 맞출 수 있는 카드 쌍의 개수를 구하는 문제이다.  

1. **카드 종류(문자열)와 해당 종류 카드들의 위치 정보(정수)를 저장하는 map 자료구조 `cards`를 선언**하고, 누군가가 짝을 맞춰서 **앞면으로 표시된 카드 종류(문자열)를 저장하기 위한 set 자료구조 `faceups`를 선언**한다.  
2. **k번의 반복을 통해** 게임 진행 상황을 입력받으면서 **카드들의 위치 정보를 `cards`(map)에 저장**한다. **카드 종류 문자열을 key로 저장**하고, **카드 위치(인덱스) 정보를 value에 저장된 set의 원소로 추가**한다.
    - case 1. 만약 게임 진행 중 누군가 카드 짝을 맞춘 경우가 생긴다면(**입력받은 카드 종류 p1과 p2가 같다면**) **`faceups`(set)에 해당 카드 종류를 추가**하고, 현재 **남은 뒷면 카드 수(`n`)에서 2를 뺀다.**
3. 이제 현재 상황에서 **확정적으로 짝지을 수 있는 카드 쌍의 개수를 나타내는 변수 `score`를 선언**하고, **정보가 드러난 카드 개수를 나타내는 `revealed` 변수를 선언**하여 **두 변수를 모두 0으로 초기화**한다.
4. map 자료구조에 저장된 카드 위치 정보를 순회한다.
    - case 1. **만약 어떤 카드 위치(value set)에 2개의 위치 정보(원소)가 저장되어 있고**, 해당 카드가 아직 아무도 맞추지 않아서 앞면으로 표시되지 않았다면(**value set에 존재하지 않는다면**) 해당 카드는 확정적으로 짝을 지을 수 있으므로 **`score` 변수를 1 올리고** 남은 뒷면 카드 수**(n)에서 2를 뺀다.**
    - case 2. 만약 어떤 카드 위치 **(value set)에 1개의 위치 정보(원소)가 저장되어 있다면** 정보가 드러낸 카드 개수 **`revealed` 변수를 1 올린다.**
5. 이제 남은 뒷면 카드 개수(`n`) 중에서 정보를 알고 있는 카드 개수(`revealed`)에 따라 추가로 짝 지을 수 있는 카드 개수를 계산한다.
    - case 1. 만약 남은 뒷면 카드 개수 **(`n`)가 2개라면,** 그 2개 카드는 무조건 똑같은 종류의 카드이므로 **score에 1을 추가**한다.
    - case 2. 만약 남은 뒷면 카드 개수 **(`n`) 중에서 정보가 밝혀진 카드 개수(`revealed`)가 절반 이상이라면(`n <= revealed * 2`)**, 아직 밝혀지지 않은 카드 중 어떤 것을 선택해도 짝이 맞는 카드의 위치를 알 수 있기 때문에 남은 카드들을 모두 짝지을 수 있다. 따라서 **score에 revealed 변수 값을 그대로 더하면 된다.** (조건문은 저렇게 되어 있지만 구조 상 revealed 변수는 n의 절반값을 초과할 수 없기 때문에 revealed는 항상 남은 뒷면 카드 수 n의 절반이 된다.)
6. 계산된 짝지을 수 있는 카드 쌍 개수 **(`score`)를 출력**한다.

#### 코멘트

문제 내용 자체는 우리가 흔히 하는 카드 짝 맞추기 게임과 똑같아서 이해하기 쉬웠으나 생각보다 구현하기 까다로웠다.  
특히 남은 카드 정보를 통해 확정적으로 짝지을 수 있는 케이스들을 모두 파악하는 과정이 쉽지 않은 문제이다.  

풀이가 좀 난잡하게 구현된데다가 반례도 꼼꼼하게 확인하지 못해서 2번이나 틀렸다.  
처음에는 남은 뒷면 카드가 2개일 때 확정적으로 짝지을 수 있다는 케이스를 놓쳐서(5번 풀이의 case 1 부분) 틀렸다.  
그래서 조건문으로 n <= 2일 때 score를 1 올리는 코드를 추가하였는데, 이 경우 남은 카드가 없을 때(n == 0)에도 score를 1 올려버리기 때문에 또 문제가 되었다.  
다시 조건문을 n == 2로 바꾼 후에야 겨우 AC를 받았다.  

제출된 코드에 facedown 이라는 변수가 선언되어 있는데 디버깅하는 과정에서 추가해놓고 정작 사용하지 않았다.  

<hr>

## D
### #5369 : Asteroid Field
https://www.acmicpc.net/problem/5369

#### 해결 상태
❌

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## E
### #24411 : Stamp Combinations
https://www.acmicpc.net/problem/24411

#### 해결 상태
❌

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## F
### #17471 : 게리맨더링
https://www.acmicpc.net/problem/17471

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/13.svg' width='30'>

#### 사용 알고리즘

**#수학**  
**#그래프 이론**  
**#브루트포스 알고리즘**  
**#그래프 탐색**  
**#너비 우선 탐색**  
**#조합론**  
#깊이 우선 탐색  

#### 풀이

각 구역의 인구 수와 인접 구역 목록이 주어지고, 각 구역을 조건에 맞게 2가지 선거구로 구분한 경우에 대하여 인구 차이의 최솟값을 찾는 문제.  
  
풀이를 요약하면, **먼저 A, B 두 가지 선거구로 나누는 모든 조합을 파악**한다.  
구역($N$)은 최대 10개이기 때문에 10개의 구역이 각각 A와 B 두 상태를 갖는 경우의 수는 $2^10 = 1024$가지 밖에 되지 않기 때문에 완전 탐색이 가능하다.  
**각 조합에 대하여 문제에서 제시한 선거구 분할 조건을 만족하는지** 그래프 탐색을 수행하여 **파악**한 후, 조건을 만족한다면 **각 선거구의 인구수 총합을 계산하여 최솟값을 갱신**하면 끝이다.

1. **각 구역에 대한 인구와 인접 구역에 대한 정보를 각각 배열 `population`과 `neighbors`에 저장**한다.
2. **구역의 선거구 지정 상태를 저장하기 위한 bool형 배열 **districts**를 선언**한다. `distircts[i]`가 true라면 $i$번 구역은 A번 선거구, false라면 B번 선거구라는 의미이다.
3. **인구수 차이의 최솟값을 나타내는 변수 `min`을 선언하고 -1로 초기화**한다.
4. 이제 선거구를 구분하는 모든 경우의 수를 탐색한 후, 선거구 분할 조건에 맞는지 파악하여 인구수 차이를 갱신한다. 나의 경우 재귀를 이용한 완전 탐색을 수행하였는데 check() 함수를 이용한 탐색 과정은 다음과 같다.
    - 4-1. 인덱스 변수 `idx`를 선언한 후, **`idx`를 1부터 시작하여 `districts[idx]`에 각각 true와 false 값을 넣는다.** 그 다음 **`idx` 값을 1 올리고 다음 재귀함수를 호출하여 이 과정을 반복**한다.
    - 4-2. **`idx`가 $N$이 되어** 모든 `districts` 원소에 true 혹은 false 값이 배정되었다면 이제 분할된 선거구가 조건에 맞는지 파악한다.
        - 4-2-1. **각 선거구의 인구수 총합을 계산하기 위한 `tcnt`, `fcnt` 변수 선언 후 0으로 초기화**한다.
        - 4-2-2. **그래프 탐색을 수행하기 위한 각 선거구의 탐색 시작 지점을 저장할 `tstart`, `fstart` 변수 선언 후 0으로 초기화**한다.
        - 4-2-3. **1 ~ $N$까지 구역들을 순회하면서 각 구역 인구수를 할당된 선거구에 따라 tcnt 또는 `fcnt`에 누적하여 더한다.** 그리고 만약 각자 선거구의 탐색 시작 지점 **`tstart` 또는 `fstart` 값이 0이라면 시작 지점을 현재 선거구로 지정**한다.
        - 4-2-4. 위 과정을 거쳤음에도 선거구 탐색 시작 지점 **`tstart` 또는 `fstart`에 값이 할당되지 않아 0이 저장되어 있다면** 선거구가 A 또는 B 한 가지 밖에 없다는 뜻이므로 **조건에 위배되기 때문에 함수를 종료**시킨다.
        - 4-2-5. 이번에는 **각 선거구 구역들이 서로 연결되어 있는지 파악하기 위한 bool형 배열 `connected`를 선언**한다. 그리고 너비 우선 탐색(BFS)을 수행하기 위한 **큐 q를 선언**한다.
        - 4-2-6. `connected` 배열에 A 선거구 탐색 시작 지점 **`tstart`와 B 선거구 탐색 시작 지점 `fstart` 인덱스 원소 값을 true로 바꾼 후, `tstart`와 `fstart`를 큐 q에 추가**한다.
        - 4-2-7. **너비 우선 탐색을 수행**하여 각 선거구의 연결 여부를 파악한다. **같은 선거구인 인접 구역이 있고 해당 인접 구역이 아직 탐색되지 않은 상태라면**, 해당 인접 구역이 탐색(연결)되었다는 의미로 **`connected[(인접 지역)]`을 true로 바꿔준 후, 큐에 추가**한다. 이 과정을 큐가 비게 될 때까지 반복한다.
        - 4-2-8. 위 과정이 끝났다면 다시 **1 ~ $N$까지 반복 변수 $i$로 구역을 순회하면서 `connected[i]`가 true인지 파악**한다. **만약 false인 경우가 존재한다면**, 연결되지 않은 지역구가 있다는 뜻이므로 **조건에 위배되기 때문에 함수를 종료**시킨다.
        - 4-2-9. 위 과정을 모두 정상적으로 마쳤다면 이번 케이스는 조건에 위배되지 않는 선거구 분할 방법이라는 뜻이다. 이제 **각 선거구의 총 인구수 차이를 계산한 후, 최솟값 `min`이 -1이거나 계산된 인구수가 `min`보다 작다면 `min`을 갱신**해준다.
5. **`min` 값을 그대로 출력**한다. 만약 조건을 만족하는 선거구 분할 방법이 존재하지 않았다면 `min` 값은 초기값 그대로 -1일 것이고, 조건을 만족하는 경우가 존재했다면 `min`이 갱신되어 최솟값을 저장하고 있을 것이다.


#### 코멘트

문제를 딱 보자마자 그래프 이론 문제인 것은 알겠는데, 문제에서 주어진 조건식을 만족하는 경우를 어떻게 파악해야 할 지 약간 고민했지만 문제 조건을 보고 완전탐색이 가능할 것이라고 판단한 후로는 딱히 어려운 점 없이 잘 풀렸다.  

역시 완전 탐색이랑 그래프 구현, BFS와 같은 개념들이 짬뽕되어 있기 때문에 각각의 개념들을 잘 섞어서 활용할 수만 있으면 그렇게 어려운 문제는 아니라고 생각한다.  
다른 사람들의 후기를 보니 마찬가지로 완전 탐색이라는 것 자체를 파악하는게 가장 까다로웠다는 의견이 많다.  

문제를 풀 때는 그래프 탐색 시 BFS로만 풀릴 것이라고 생각했는데 나중에 보니 최단경로를 구하는 것이 아니라 단순히 그래프 연결 여부만 파악하면 되기 때문에 때문에 DFS로도 풀이가 가능했다.

<hr>

## G
### #31228 : 실 전화기
https://www.acmicpc.net/problem/31228

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## H
### #3936 : Molecular Formula 
https://www.acmicpc.net/problem/3936

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/15.svg' width='30'>

#### 사용 알고리즘

**#구현**  
**#자료 구조**  
**#문자열**  
**#트리를 사용한 집합과 맵**  
**#파싱**  
**#스택**  
#재귀  
**#해싱**  

#### 풀이

문제에서 원자 종류와 원자량, 그리고 분자식이 주어지고 분자식에 따라 주어진 원자만으로 분자를 구성할 수 있는지 여부를 검증한 후, 구성할 수 있다면 해당 분자의 총 원자량을 계산하는 문제.  
  
1. 먼저 **map 자료구조를 생성**하고 무한루프를 돌려 **입력받는 원자의 원자 기호(문자열)과 원자량(정수)을 저장**한다. "END_OF_FIRST_PART"가 입력되면 원자 입력 루프문을 종료한다.
2. 다음으로 또 무한루프를 돌려 **분자식을 문자열로 입력**받는다. 입력받은 문자열이 "0"이면 분자식 입력 루프문을 종료한다.
    - 2-1. 원자량을 계산하는데 필요한 여러가지 변수들을 선언한다.  
        - 2-1-1. 현재까지의 누적된 총 원자량을 나타낼 변수 **sum**을 선언하여 0으로 초기화한다. 
        - 2-1-2 분자식 문자열을 순회하기 위한 인덱스 변수 **idx**를 선언하여 0으로 초기화한다.
        - 2-1-3. 괄호 연산을 처리하기 위한 정수 스택 **st**를 선언한다.
        - 2-1-4. 유효한 분자식인지를 검증할 bool 변수 **valid**를 선언하고 일단 true로 초기화해놓는다.
    - 2-2. **분자식 문자열을 idx 변수로 순회**하면서 아래와 같은 과정을 거친다.
        - case 1. **여는 괄호('(')가 나왔다면** 지금까지 누적된 원자량 **(sum) 값을 스택에 보존**하고 이번 괄호 안의 누적 원자량 값을 저장하기 위해 **sum을 0으로 초기화**한다.
        - case 2. **닫는 괄호(')')가 나왔다면** 뒤에 숫자가 나오는지 확인한다. 
            - case 2-1. **숫자가 있다면** 숫자가 얼마인지 파악하여 괄호 안에서의 원자량 누적값 **sum에 숫자만큼 곱해준다.** 그 이후 스택에 보존되어 있는 **괄호 밖의 누적값(st.top())과 괄호 안의 누적값(sum)을 합쳐서 sum 변수에 저장**한다. **사용한 스택 값은 제거**한다. 
            - case 2-2. **숫자가 없다면** 위 과정을 sum에 곱하는 과정 없이 **바로 스택 값과 sum 값을 더해준 후 사용한 스택 값을 제거**한다.
        - case 3. **영어 대문자가 나왔다면** 원자를 나타내는 것이므로 **원자 기호를 파악**한다. **뒤의 문자가 소문자이면 뒤의 문자까지 포함하여 원자 기호를 구성**해준다.
            - case 3-1. **만약 원자 구성이 map에 존재하지 않는다면** 선언되지 않은 원자이므로 원자량을 계산할 수 없다. **검증 변수(valid)를 false로 바꾸고 분자식 문자열 순회를 종료**한다. 
            - case 3-2 **원자 구성이 map에 존재한다면** 해당 원자의 원자량 값을 map에서 가져온다. 그리고 분자식 뒤에 숫자가 붙어있다면 해당 숫자를 파악해서 **원자량 값을 뒤의 숫자만큼 곱해주고, 곱한 값을 원자량 누적값 sum에 더해준다.**
    - 2-3 어떤 식으로든 문자열 순회가 종료된 후에, **검증 변수가 false이면** 원자량을 알 수 없다는 의미의 **"UNKNOWN" 문자열을 출력**하고, **검증 변수가 true이면** 입력된 분자식에 대하여 계산된 **원자량 누적 값(sum)을 출력**한다.


#### 코멘트

최초로 랜덤 마라톤에서 골드 1 문제를 해결해버렸다.  
이딴 게 골드 1? 개인적으로 좀 많이 과대평가된 난이도 같다.  
  
지문에 웬 화학식이 나와서 쫄았으나, 문제 지문을 찬찬히 읽고 예제를 분석하니 감이 좀 잡혔다.  
문자열 파싱부터 시작해서 스택 & 맵 자료구조를 응용하고, 약간의 구현 요소를 짬뽕해놓은 문제이다.  
잡기술이 많이 들어가고 문자열 순회할 때 인덱스 처리가 좀 많이 골치아팠던 것 외에는 생각보다 할 만한 문제였다.  
알고리즘에 재귀가 들어가 있는데 나는 스택으로 해결했기 때문에 재귀는 안 썼다.  

