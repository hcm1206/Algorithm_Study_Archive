# solved\.ac 랜덤 마라톤 40주차

<hr>

## A
### #21638 : SMS from MCHS
https://www.acmicpc.net/problem/21638

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/2.svg' width='30'>

#### 사용 알고리즘

**#구현**

#### 풀이

if-else 문을 이용한 단순 조건문 비교 구현 문제.  
1. 만약(`if`) **내일 기온 $t_2$가 0 미만이고 내일 풍속 $v_2$가 10 이상**이면 폭풍 알림 문자열을 출력한다.  
2. 그렇지 않고(`else if`) **내일 기온 $t_2$가 오늘 기온 $t_2$보다 작다면** 낮은 기온 경고 알림 문자열을 출력한다.  
3. 그렇지 않고(`else if`) **내일 풍속 $v_2$가 오늘 풍속 $v_1$보다 크다면** 강풍 경고 알림 문자열을 출력한다.  
4. **위 모든 경우에 해당하지 않으면**(`else`) 보낼 메시지가 없다고 출력한다.  

#### 코멘트

영어 지문이 쓸데없이 길어서 귀찮았던 것 빼면 A번 답게 무난했다.  

다만 예제 출력1 부분에 
```
MCHS warns! Low temperature
is expected tomorrow.
```
위와 같이 임의로 문자열이 개행되어 있어서 좀 당황했는데, 문제 출력 부분 설명을 다시 읽어보니
```
You can separate message words with spaces and line feeds arbitrarily.
(출력되는 메시지의 단어들은 공백 또는 줄바꿈 문자로 자유롭게 구분될 수 있다.)
```
가 적혀있었다.   
무슨 원리인진 모르겠지만 그냥 줄바꿈 안 하고 출력했더니 통과되었다.  
역시 지문은 꼼꼼하게 읽어야 한다는 교훈을 $N$번째 재확인하게 되었다. ($1 \leq N \leq 10^9$)  


<hr>

## B
### #15270 : 친구 펠린드롬
https://www.acmicpc.net/problem/15270

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/10.svg' width='30'>

#### 사용 알고리즘
 
**#그래프 이론**  
**#브루트포스 알고리즘**  
**#그래프 탐색**  
**#깊이 우선 탐색**  
**#백트래킹**  

#### 풀이

친한 친구들의 목록을 토대로 무대에 올릴 수 있는 친한 친구 쌍 + 아싸 한 명을 최대화할 수 있는 수를 찾는 문제.

1. **친한 친구 쌍을 입력받아** `set<pair<int, int>>`로 선언된 **`friends`에 저장**한다.
2. **짝을 지을 수 있는지 여부를 저장할 $N$(반 친구 수) 크기의 bool형 배열 `valid`를 선언**하고 원소를 모두 **true로 초기화**한다.
3. **최대값을 저장할 `max` 변수를 선언하고 0으로 초기화**한다.
4. **`backtrack()` 함수를 이용하여 백트래킹 완전탐색을 수행**한다. `valid` 배열(참조), `friends` 집합(참조), $N$, 시작 인덱스 `idx`(초기 입력값 0), 현재 무대에 세워진 친구 `onstage`(초기 입력값 0), 최대값 `max`(참조)를 매개변수로 입력한다.
    - 4-1. 이번 순회에서 **짝이 지어졌는지 여부를 확인할 bool 변수 `notpaired`를 선언하고 true로 초기화**한다. 또한 이번 순회를 돌며 **남은 친구가 있는지 여부를 확인할 bool 변수 `noleft` 변수를 선언하고 true로 초기화**한다.
    - 4-2. **`i` 반복변수를 이용하여** 인덱스 시작 지점 **`idx`부터** 시작하여 **`$N$`까지 반복**한다.
        - 4-2-1. 이번 `i` 인덱스에 해당하는 친구가 짝지을 수 없는 상태 **(`valid[i] == false`)라면 이번 반복을 생략하고 다음 반복을 수행**한다.
        - 4-2-2. `i` 인덱스 친구가 아직 짝지어지지 않은 상태이므로 **`noleft`를 false로 바꾼다.** (남은 친구가 있음)
        - 4-2-3. **`j` 반복변수를 이용하여 `i + 1`부터 `$N$`까지 반복**한다.
        - 4-2-4. 만약 **`j` 인덱스 친구가 아직 짝지어지지 않았고 `i`와 `j` 친구가 친한 친구라면**(friends 집합에 {i, j} 쌍이 존재한다면) **`valid[i]`와 `valid[j]`를** 짝지어졌다는 표시로 **true로 바꿔준다.**
        - 4-2-5. 이제 `i` 이전 인덱스는 모두 확인했으므로 인덱스 시작 지점 **`idx`를 i + 1로 설정하고, `onstage`에 2를 추가하여 backtrack() 함수를 재귀적으로 호출**한다.
        - 4-2-6. 위 재귀 호출이 끝나면 **`valid[i]`와 `valid[j]`를 원래 값인 false로 바꿔준다.**
        - 4-2-7. 짝지어진 친구가 있으므로 **`notpaired`를 false로 바꾼다.**
    - 4-3. **위 순회를 거치며 짝지어진 친구가 없다면**(`notpaired == true`), 현재 상태에서 무대에 친구를 더 올릴 수 없다는 의미이다. 
        - 4-3-1 만약 **짝지어지지 않고 남은 친구가 있다면**(`noleft == false`) 남은 친구 중 한 명을 가운데에서 로봇 댄스를 시키기 위해 무대에 올릴 수 있으므로 **`onstage` 값을 1 추가**한다.
        - 4-3-2 **`onstage`가 최대값 `max`보다 크다면 `max` 값을 `onstage` 값으로 갱신**한다.
5. 계산된 **`max` 최댓값을 출력**한다.

#### 코멘트

B번 주제에 거의 3일을 애먹였던 함정 문제였다. 단순해 보이는 첫 이미지에 비해 접근법도 쉽지 않았고 완전탐색을 최적화하는 발상도 까다로웠다.

처음에는 완전탐색이 어려울 것 같아서 그리디한 접근법으로 가장 친구가 적은 친구부터 짝짓는 방식으로 최댓값을 구하려 했으나 WA를 받았다. 뭔가 반례가 있는 모양인데 결국 찾지는 못했다.  
일단 1~$N$을 이중으로 반복해서 가능한 쌍을 하나씩 추가하는 방식으로 다시 완전탐색을 수행하였으나 실행시간이 길어져 시간초과가 예상되었다.
결국 백트래킹을 이용해서 1~$N$ 범위 중 이미 탐색한 범위는 제외하는 방식으로 최적화를 수행하였더니 시간 안에 AC를 받았다.

딱히 깊이 우선 그래프 탐색이라고 생각하고 풀지는 않았는데 풀고 나서 알고리즘 태그를 보니 그래프 탐색, DFS가 적혀있었다. 사실 내가 구현한 백트래킹 구현 방식이 DFS라면 DFS라고 볼 수 있을 것 같기는 하다.

다른 사람들의 후기를 보니 완전탐색을 1~$N$ 중에서 하나를 고르는 것이 아닌 입력받은 친한 친구 쌍을 기준으로 수행하는 방법도 있다고 한다. 

<hr>

## C
### #13348 : Memory Match
https://www.acmicpc.net/problem/13348

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/10.svg' width='30'>

#### 사용 알고리즘

**#구현**  
**#많은 조건 분기**  

#### 풀이

카드 짝 맞추기 게임 구현 문제.  
주어진 조건과 게임 진행 상황을 기준으로 현재 상황에서 찍지 않고 확정적으로 짝을 맞출 수 있는 카드 쌍의 개수를 구하는 문제이다.  

1. **카드 종류(문자열)와 해당 종류 카드들의 위치 정보(정수)를 저장하는 map 자료구조 `cards`를 선언**하고, 누군가가 짝을 맞춰서 **앞면으로 표시된 카드 종류(문자열)를 저장하기 위한 set 자료구조 `faceups`를 선언**한다.  
2. **k번의 반복을 통해** 게임 진행 상황을 입력받으면서 **카드들의 위치 정보를 `cards`(map)에 저장**한다. **카드 종류 문자열을 key로 저장**하고, **카드 위치(인덱스) 정보를 value에 저장된 set의 원소로 추가**한다.
    - case 1. 만약 게임 진행 중 누군가 카드 짝을 맞춘 경우가 생긴다면(**입력받은 카드 종류 p1과 p2가 같다면**) **`faceups`(set)에 해당 카드 종류를 추가**하고, 현재 **남은 뒷면 카드 수(`n`)에서 2를 뺀다.**
3. 이제 현재 상황에서 **확정적으로 짝지을 수 있는 카드 쌍의 개수를 나타내는 변수 `score`를 선언**하고, **정보가 드러난 카드 개수를 나타내는 `revealed` 변수를 선언**하여 **두 변수를 모두 0으로 초기화**한다.
4. map 자료구조에 저장된 카드 위치 정보를 순회한다.
    - case 1. **만약 어떤 카드 위치(value set)에 2개의 위치 정보(원소)가 저장되어 있고**, 해당 카드가 아직 아무도 맞추지 않아서 앞면으로 표시되지 않았다면(**value set에 존재하지 않는다면**) 해당 카드는 확정적으로 짝을 지을 수 있으므로 **`score` 변수를 1 올리고** 남은 뒷면 카드 수**(n)에서 2를 뺀다.**
    - case 2. 만약 어떤 카드 위치 **(value set)에 1개의 위치 정보(원소)가 저장되어 있다면** 정보가 드러낸 카드 개수 **`revealed` 변수를 1 올린다.**
5. 이제 남은 뒷면 카드 개수(`n`) 중에서 정보를 알고 있는 카드 개수(`revealed`)에 따라 추가로 짝 지을 수 있는 카드 개수를 계산한다.
    - case 1. 만약 남은 뒷면 카드 개수 **(`n`)가 2개라면,** 그 2개 카드는 무조건 똑같은 종류의 카드이므로 **score에 1을 추가**한다.
    - case 2. 만약 남은 뒷면 카드 개수 **(`n`) 중에서 정보가 밝혀진 카드 개수(`revealed`)가 절반 이상이라면(`n <= revealed * 2`)**, 아직 밝혀지지 않은 카드 중 어떤 것을 선택해도 짝이 맞는 카드의 위치를 알 수 있기 때문에 남은 카드들을 모두 짝지을 수 있다. 따라서 **score에 revealed 변수 값을 그대로 더하면 된다.** (조건문은 저렇게 되어 있지만 구조 상 revealed 변수는 n의 절반값을 초과할 수 없기 때문에 revealed는 항상 남은 뒷면 카드 수 n의 절반이 된다.)
6. 계산된 짝지을 수 있는 카드 쌍 개수 **(`score`)를 출력**한다.

#### 코멘트

문제 내용 자체는 우리가 흔히 하는 카드 짝 맞추기 게임과 똑같아서 이해하기 쉬웠으나 생각보다 구현하기 까다로웠다.  
특히 남은 카드 정보를 통해 확정적으로 짝지을 수 있는 케이스들을 모두 파악하는 과정이 쉽지 않은 문제이다.  

풀이가 좀 난잡하게 구현된데다가 반례도 꼼꼼하게 확인하지 못해서 2번이나 틀렸다.  
처음에는 남은 뒷면 카드가 2개일 때 확정적으로 짝지을 수 있다는 케이스를 놓쳐서(5번 풀이의 case 1 부분) 틀렸다.  
그래서 조건문으로 n <= 2일 때 score를 1 올리는 코드를 추가하였는데, 이 경우 남은 카드가 없을 때(n == 0)에도 score를 1 올려버리기 때문에 또 문제가 되었다.  
다시 조건문을 n == 2로 바꾼 후에야 겨우 AC를 받았다.  

제출된 코드에 facedown 이라는 변수가 선언되어 있는데 디버깅하는 과정에서 추가해놓고 정작 사용하지 않았다.  

<hr>

## D
### #5369 : Asteroid Field
https://www.acmicpc.net/problem/5369

#### 해결 상태
❌

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/relative-0.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## E
### #24411 : Stamp Combinations
https://www.acmicpc.net/problem/24411

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/11.svg' width='30'>

#### 사용 알고리즘

#자료 구조  
**#브루트포스 알고리즘**  
**#이분 탐색**  
**#누적 합**  
#해시를 사용한 집합과 맵  
#트리를 사용한 집합과 맵  

**#두 포인터**

#### 풀이

개수가 각각 다른 우표뭉치 롤지의 앞과 뒤에서부터 뭉치들을 연속적으로 묶어 원하는 우표 개수를 구할 수 있는지 판별하는 문제.

1. 각각의 우표뭉치에 포함된 **우표 개수를 입력받아 $M$ 크기의 배열 `psum`에 누적합 형식으로 저장**한다.
2. 찾고자 하는 우표 개수 `q`를 입력받은 후 아래 과정을 통해 우표 롤지를 뜯어서 **`q`를 만들 수 있는지 검증**한다.
    - 2-1. 먼저 0으로 초기화한 `lidx`, $M$으로 초기화한 `ridx`를 선언하고 **이분탐색을 통해 첫 번째 우표뭉치부터 시작하여 누적값이 `q`보다 크거나 같아지는 우표뭉치 지점을 찾고 해당 지점 인덱스를 `ridx`에 저장**한다.
    - 2-2. `q` 값을 찾았는지 여부를 검증할 **bool 변수 `found`를 선언하고 false로 초기화**한다. 그리고 이분탐색에 사용했던 **`lidx`를 0으로 초기화**한다.
    - 2-3. 다음으로 `lidx`와 `ridx`를 이용하여 **투 포인터 순회**를 한다. 과정은 아래와 같다.
        - 2-3-1. 만약 **`ridx`가 0보다 작다면** 롤지의 첫지점과 끝지점에서 시작하는 케이스가 끝났다는 의미이므로 **순회를 종료**한다. **또는 `ridx`가 `m - lidx`보다 크다면** 롤지의 모든 뭉치를 누적해도 `q` 값에 도달하지 못한다는 의미이므로 **순회를 종료**한다.
        - 2-3-2. 롤지의 시작 지점부터 ridx 지점 뭉치까지의 누적값 **(`psum[ridx]`)과** 롤지의 마지막 지점부터 n - lidx 지점 뭉치까지의 누적값 **(`psum[m] - psum[lidx]`)의 합 `nowsum`을 계산**한다. 그리고 `nowsum`의 값에 따라 아래 과정을 수행한다.
            - case 1. **`nowsum` 값이 `q`와 같다면** `q`를 찾았으므로 **`found` 변수를 true로 바꾸고 순회를 종료**한다.
            - case 2. **`nowsum` 값이 `q`보다 작다면* `lidx`를 1 증가**한다. 즉, 롤지 마지막 지점에서부터 누적되는 우표뭉치를 하나 추가하여 누적 값을 늘린다.
            - case 3. **`nowsum` 값이 `q`보다 크다면 `ridx`를 1 감소**한다. 즉, 롤지 시작 지점에서부터 누적되는 우표뭉치를 하나 제거하여 누적 값을 줄인다.
        - 2-3-3. **`q`를 찾지 못했다면 2-3-1 과정으로 돌아가 탐색을 계속**한다.
    - 2-4. **`found`가 true이면 Yes를 출력하고, false이면 No를 출력**한다.
        
#### 코멘트

기본적으로 누적합을 사용하는 문제인데 후기를 보니 사람마다 풀이 방법이 굉장히 다양한 것 같다. 누적합을 토대로 나올 수 있는 모든 값을 집합에 저장하여 쿼리마다 검증하는 방법이 있고, 전체 누적값에서 제외할 구간을 두 포인터로 계산해서 빼는 방법도 있다. 나는 두 포인터를 이용하여 양 끝의 누적값을 더하는 색다른 방식으로 쿼리값을 구하였다.  
얼핏보고 $N$과 $M$의 제한이 백만이라서 두 포인터 연산에 $O(N)$이 걸리고, 쿼리가 $M$개 있기 때문에 $O(N × M)$으로 연산이 1조가 되는 것 아닌가 싶었지만, $M × N \leq 10^{7}$ 이라는 제한이 있었기 때문에 의외로 널널하게 풀 수 있었다.

발상 난이도도 그렇고 알고리즘 여러 개를 응용해야 하는 문제라서 난이도가 좀 있을 줄 알았는데 골드 5라고 한다. 풀어놓고 보니 뭔가 납득 되는 것 같기도 하고 애매하다.



<hr>

## F
### #17471 : 게리맨더링
https://www.acmicpc.net/problem/17471

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/13.svg' width='30'>

#### 사용 알고리즘

**#수학**  
**#그래프 이론**  
**#브루트포스 알고리즘**  
**#그래프 탐색**  
**#너비 우선 탐색**  
**#조합론**  
#깊이 우선 탐색  

#### 풀이

각 구역의 인구 수와 인접 구역 목록이 주어지고, 각 구역을 조건에 맞게 2가지 선거구로 구분한 경우에 대하여 인구 차이의 최솟값을 찾는 문제.  
  
풀이를 요약하면, **먼저 A, B 두 가지 선거구로 나누는 모든 조합을 파악**한다.  
구역($N$)은 최대 10개이기 때문에 10개의 구역이 각각 A와 B 두 상태를 갖는 경우의 수는 $2^{10} = 1024$가지 밖에 되지 않기 때문에 완전 탐색이 가능하다.  
**각 조합에 대하여 문제에서 제시한 선거구 분할 조건을 만족하는지** 그래프 탐색을 수행하여 **파악**한 후, 조건을 만족한다면 **각 선거구의 인구수 총합을 계산하여 최솟값을 갱신**하면 끝이다.

1. **각 구역에 대한 인구와 인접 구역에 대한 정보를 각각 배열 `population`과 `neighbors`에 저장**한다.
2. **구역의 선거구 지정 상태를 저장하기 위한 bool형 배열 **districts**를 선언**한다. `distircts[i]`가 true라면 $i$번 구역은 A번 선거구, false라면 B번 선거구라는 의미이다.
3. **인구수 차이의 최솟값을 나타내는 변수 `min`을 선언하고 -1로 초기화**한다.
4. 이제 선거구를 구분하는 모든 경우의 수를 탐색한 후, 선거구 분할 조건에 맞는지 파악하여 인구수 차이를 갱신한다. 나의 경우 재귀를 이용한 완전 탐색을 수행하였는데 check() 함수를 이용한 탐색 과정은 다음과 같다.
    - 4-1. 인덱스 변수 `idx`를 선언한 후, **`idx`를 1부터 시작하여 `districts[idx]`에 각각 true와 false 값을 넣는다.** 그 다음 **`idx` 값을 1 올리고 다음 재귀함수를 호출하여 이 과정을 반복**한다.
    - 4-2. **`idx`가 $N$이 되어** 모든 `districts` 원소에 true 혹은 false 값이 배정되었다면 이제 분할된 선거구가 조건에 맞는지 파악한다.
        - 4-2-1. **각 선거구의 인구수 총합을 계산하기 위한 `tcnt`, `fcnt` 변수 선언 후 0으로 초기화**한다.
        - 4-2-2. **그래프 탐색을 수행하기 위한 각 선거구의 탐색 시작 지점을 저장할 `tstart`, `fstart` 변수 선언 후 0으로 초기화**한다.
        - 4-2-3. **1 ~ $N$까지 구역들을 순회하면서 각 구역 인구수를 할당된 선거구에 따라 tcnt 또는 `fcnt`에 누적하여 더한다.** 그리고 만약 각자 선거구의 탐색 시작 지점 **`tstart` 또는 `fstart` 값이 0이라면 시작 지점을 현재 선거구로 지정**한다.
        - 4-2-4. 위 과정을 거쳤음에도 선거구 탐색 시작 지점 **`tstart` 또는 `fstart`에 값이 할당되지 않아 0이 저장되어 있다면** 선거구가 A 또는 B 한 가지 밖에 없다는 뜻이므로 **조건에 위배되기 때문에 함수를 종료**시킨다.
        - 4-2-5. 이번에는 **각 선거구 구역들이 서로 연결되어 있는지 파악하기 위한 bool형 배열 `connected`를 선언**한다. 그리고 너비 우선 탐색(BFS)을 수행하기 위한 **큐 q를 선언**한다.
        - 4-2-6. `connected` 배열에 A 선거구 탐색 시작 지점 **`tstart`와 B 선거구 탐색 시작 지점 `fstart` 인덱스 원소 값을 true로 바꾼 후, `tstart`와 `fstart`를 큐 q에 추가**한다.
        - 4-2-7. **너비 우선 탐색을 수행**하여 각 선거구의 연결 여부를 파악한다. **같은 선거구인 인접 구역이 있고 해당 인접 구역이 아직 탐색되지 않은 상태라면**, 해당 인접 구역이 탐색(연결)되었다는 의미로 **`connected[(인접 지역)]`을 true로 바꿔준 후, 큐에 추가**한다. 이 과정을 큐가 비게 될 때까지 반복한다.
        - 4-2-8. 위 과정이 끝났다면 다시 **1 ~ $N$까지 반복 변수 $i$로 구역을 순회하면서 `connected[i]`가 true인지 파악**한다. **만약 false인 경우가 존재한다면**, 연결되지 않은 지역구가 있다는 뜻이므로 **조건에 위배되기 때문에 함수를 종료**시킨다.
        - 4-2-9. 위 과정을 모두 정상적으로 마쳤다면 이번 케이스는 조건에 위배되지 않는 선거구 분할 방법이라는 뜻이다. 이제 **각 선거구의 총 인구수 차이를 계산한 후, 최솟값 `min`이 -1이거나 계산된 인구수가 `min`보다 작다면 `min`을 갱신**해준다.
5. **`min` 값을 그대로 출력**한다. 만약 조건을 만족하는 선거구 분할 방법이 존재하지 않았다면 `min` 값은 초기값 그대로 -1일 것이고, 조건을 만족하는 경우가 존재했다면 `min`이 갱신되어 최솟값을 저장하고 있을 것이다.


#### 코멘트

문제를 딱 보자마자 그래프 이론 문제인 것은 알겠는데, 문제에서 주어진 조건식을 만족하는 경우를 어떻게 파악해야 할 지 약간 고민했지만 문제 조건을 보고 완전탐색이 가능할 것이라고 판단한 후로는 딱히 어려운 점 없이 잘 풀렸다.  

역시 완전 탐색이랑 그래프 구현, BFS와 같은 개념들이 짬뽕되어 있기 때문에 각각의 개념들을 잘 섞어서 활용할 수만 있으면 그렇게 어려운 문제는 아니라고 생각한다.  
다른 사람들의 후기를 보니 마찬가지로 완전 탐색이라는 것 자체를 파악하는게 가장 까다로웠다는 의견이 많다.  

문제를 풀 때는 그래프 탐색 시 BFS로만 풀릴 것이라고 생각했는데 나중에 보니 최단경로를 구하는 것이 아니라 단순히 그래프 연결 여부만 파악하면 되기 때문에 때문에 DFS로도 풀이가 가능했다.

<hr>

## G
### #31228 : 실 전화기
https://www.acmicpc.net/problem/31228

#### 해결 상태
❌

#### 난이도
<img src='https://static.solved.ac/tier_small/relative-1.svg' width='30'>

#### 사용 알고리즘


#### 풀이


#### 코멘트

<hr>

## H
### #3936 : Molecular Formula 
https://www.acmicpc.net/problem/3936

#### 해결 상태
✅

#### 난이도
<img src='https://d2gd6pc034wcta.cloudfront.net/tier/15.svg' width='30'>

#### 사용 알고리즘

**#구현**  
**#자료 구조**  
**#문자열**  
**#트리를 사용한 집합과 맵**  
**#파싱**  
**#스택**  
#재귀  
**#해싱**  

#### 풀이

문제에서 원자 종류와 원자량, 그리고 분자식이 주어지고 분자식에 따라 주어진 원자만으로 분자를 구성할 수 있는지 여부를 검증한 후, 구성할 수 있다면 해당 분자의 총 원자량을 계산하는 문제.  
  
1. 먼저 **map 자료구조를 생성**하고 무한루프를 돌려 **입력받는 원자의 원자 기호(문자열)과 원자량(정수)을 저장**한다. "END_OF_FIRST_PART"가 입력되면 원자 입력 루프문을 종료한다.
2. 다음으로 또 무한루프를 돌려 **분자식을 문자열로 입력**받는다. 입력받은 문자열이 "0"이면 분자식 입력 루프문을 종료한다.
    - 2-1. 원자량을 계산하는데 필요한 여러가지 변수들을 선언한다.  
        - 2-1-1. 현재까지의 누적된 총 원자량을 나타낼 변수 **sum**을 선언하여 0으로 초기화한다. 
        - 2-1-2 분자식 문자열을 순회하기 위한 인덱스 변수 **idx**를 선언하여 0으로 초기화한다.
        - 2-1-3. 괄호 연산을 처리하기 위한 정수 스택 **st**를 선언한다.
        - 2-1-4. 유효한 분자식인지를 검증할 bool 변수 **valid**를 선언하고 일단 true로 초기화해놓는다.
    - 2-2. **분자식 문자열을 idx 변수로 순회**하면서 아래와 같은 과정을 거친다.
        - case 1. **여는 괄호('(')가 나왔다면** 지금까지 누적된 원자량 **(sum) 값을 스택에 보존**하고 이번 괄호 안의 누적 원자량 값을 저장하기 위해 **sum을 0으로 초기화**한다.
        - case 2. **닫는 괄호(')')가 나왔다면** 뒤에 숫자가 나오는지 확인한다. 
            - case 2-1. **숫자가 있다면** 숫자가 얼마인지 파악하여 괄호 안에서의 원자량 누적값 **sum에 숫자만큼 곱해준다.** 그 이후 스택에 보존되어 있는 **괄호 밖의 누적값(st.top())과 괄호 안의 누적값(sum)을 합쳐서 sum 변수에 저장**한다. **사용한 스택 값은 제거**한다. 
            - case 2-2. **숫자가 없다면** 위 과정을 sum에 곱하는 과정 없이 **바로 스택 값과 sum 값을 더해준 후 사용한 스택 값을 제거**한다.
        - case 3. **영어 대문자가 나왔다면** 원자를 나타내는 것이므로 **원자 기호를 파악**한다. **뒤의 문자가 소문자이면 뒤의 문자까지 포함하여 원자 기호를 구성**해준다.
            - case 3-1. **만약 원자 구성이 map에 존재하지 않는다면** 선언되지 않은 원자이므로 원자량을 계산할 수 없다. **검증 변수(valid)를 false로 바꾸고 분자식 문자열 순회를 종료**한다. 
            - case 3-2 **원자 구성이 map에 존재한다면** 해당 원자의 원자량 값을 map에서 가져온다. 그리고 분자식 뒤에 숫자가 붙어있다면 해당 숫자를 파악해서 **원자량 값을 뒤의 숫자만큼 곱해주고, 곱한 값을 원자량 누적값 sum에 더해준다.**
    - 2-3 어떤 식으로든 문자열 순회가 종료된 후에, **검증 변수가 false이면** 원자량을 알 수 없다는 의미의 **"UNKNOWN" 문자열을 출력**하고, **검증 변수가 true이면** 입력된 분자식에 대하여 계산된 **원자량 누적 값(sum)을 출력**한다.


#### 코멘트

최초로 랜덤 마라톤에서 골드 1 문제를 해결해버렸다.  
이딴 게 골드 1? 개인적으로 좀 많이 과대평가된 난이도 같다.  
  
지문에 웬 화학식이 나와서 쫄았으나, 문제 지문을 찬찬히 읽고 예제를 분석하니 감이 좀 잡혔다.  
문자열 파싱부터 시작해서 스택 & 맵 자료구조를 응용하고, 약간의 구현 요소를 짬뽕해놓은 문제이다.  
잡기술이 많이 들어가고 문자열 순회할 때 인덱스 처리가 좀 많이 골치아팠던 것 외에는 생각보다 할 만한 문제였다.  
알고리즘에 재귀가 들어가 있는데 나는 스택으로 해결했기 때문에 재귀는 안 썼다.  

